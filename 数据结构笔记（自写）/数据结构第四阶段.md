## 第四阶段

😀 😃 🥰 😍 😘

❤️ ✨⭐ ❗❓❕❔

✊✌️ ✋✋ ☝️ 👏 🤝

☀️ ☔ ☁️ ❄️ ⛄ ⚡ ⛅

⛪ ⛺ ⛲ ⛵ ⛵ ⚓ ✈️ ⛽ ⚠️ ♨️

1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 0️⃣

️⃣ ◀️ ⬇️ ▶️ ⬅️ ↙️ ↘️ ➡️ ⬆️ ↖️ ↗️
⏬ ⏫ ⤵️ ⤴️ ↩️ ↪️ ↔️ ↕️ ⏪ ⏩ ℹ️ ️ ️ ️

♿ ㊙️ ㊗️ Ⓜ️ ⛔ ✳️ ❇️ ✴️

♈ ♉ ♊ ♋ ♌ ♍ ♎ ♏ ♐ ♑ ♒ ♓ ⛎

❎ ️ ️ ️ ♻️ ©️ ®️ ™️ ❌ ❗ ‼️ ⁉️ ⭕ ✖️ ➕ ➖ ➗ ✔️

☑️ ➰ 〰️ 〽️ ▪️ ▫️ ◾ ◽ ◼️ ◻️ ⬛ ⬜ ✅ ⚫ ⚪
————————————————

### 查找：

概论：

查找表（Search Table）：同一类型的数据元素（或记录）构成的集合

关键字（Key）：数据元素中某一个数据项的值，又称键值

主关键字（Primary Key）：唯一地标识一个记录的关键字，主关键字所在数据项称为主关键码

次关键字（Secondary Key）：标识多个数据元素的关键字，主关键字所在数据项称为主关键码

![](C:\Typora\picture\关键字.png)

**查找**：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素

两大查找方式：静态查找表和动态查找表

> 静态查找表：只做查找操作
>
> 动态查找表：查找过程中同时插入查找表中不存在的数据元素，或者删除查找表中已经存在的元素

#### 顺序表查找：

又称线性查找，最基本

过程：从第一个记录开始，逐个进行记录的关键字和给定值比较，若相等，则查找成功

代码实现：

```c++
//顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字
int squentialSearch(int* a, int n,int key)
{
	int i;
	for (i = 1; i <= n; i++)
	{
		if (a[i] == key)
		{
			return i;
		}
	}
	return 0;
}
```

优化：设置一个哨兵，减少判断次数

以下是设置头部为哨兵，也可以设置尾部，原理一致

```c++
//有哨兵顺序查找
int sequentialSearch2(int* a, int n, int key)
{
	int i;
	a[0] = key;//设置哨兵

	i = n;
	while (a[i] != key)
	{
		i--;
	}
	return i;//返回0则失败
}
```

改造后看似影响不大，但数据多时会有体现

顺序查找的时间复杂度为O(n)，显然缺点明显，效率低下

#### 有序表查找：

##### 1、二分查找

又称折半查找，前提是线性表中记录的关键码有序（通常从小到大），线性表需要顺序储存

精髓：取中间值，小于中间则取左半区，大于中间则取右半区，不断重复

代码实现：

```c++
int binarySearch(int* a, int n, int key)
{
	int left, right, mid;
	left = 1;
	right = n;
	while (left <= right)
	{
		mid = (right - left) / 2 + left;//折半
		if (key < a[mid])
		{
			right = mid - 1;//在左半区查找
		}
		else if (key > a[mid])
		{
			left = mid + 1;//在右半区查找
		}
		else
		{
			return mid;//找到
		}
	}
	return 0;//未找到返回0
}
```

时间复杂度：O(logn)

##### 2、插值查找：

主要原理还是二分查找，情景引入，假如你从字典中找zoo和apple，你一定从中间开始，而是有意识的从更靠近结果的首尾开始

主要改进：改进该式==（mid = (right - left) / 2 + left）中的1/2改成==

==(key - a[low])/(a[high] - a[low])==，分析式子可得假如离low更近mid也会更小，可以更快的缩小查找区间以加速，数据较为均匀的情况下会更加快

```c++
		//mid = (right - left) / 2 + left;//折半改为
		mid = (right - left) * (key - a[low])/(a[high] - a[low])+ left;
```

时间复杂度：O(logn)

##### 3、斐波那契查找

主要区别也是把mid的表达式换掉，黄金分割比是大自然的神奇之处，所以算法工程师也往这边想，mid使数组左右数形成黄金分割比，部分情况会更快，但也有可能普通的二分查找更加快。所以三个排序要自己考虑，某些情况可能会使程序提升较多性能。

```c++
#define MAXSIZE 20
int F[MAXSIZE];//斐波那契数列
//斐波那契查找
void fib()
{
	F[0] = 0;
	F[1] = 1;
	for (int i = 2; i < MAXSIZE; i++)
	{
		F[i] = F[i - 1] + F[i - 2];
	}
}

int fibSearch(int* a, int n, int key)
{
	int left, right, mid, i, k;
	left = 1;//最低下标记录首位
	right = n;//最高下标记录末尾
	k = 0;
	while (n > F[k] - 1)
	{
		k++;
	}
	for (i = n; i < F[k] - 1; i++)//不满的数值补全
	{
		a[i] = a[n];
	}
	while (left <= right)
	{
		mid = left + F[k - 1] - 1;//当前下标，也就是斐波那契的前部分
		if (key < a[mid])//若小于当前分隔
		{
			left = mid - 1;//最高下标调整
			k = k - 1;//斐波那契减一位
		}
		else if (key > a[mid])
		{
			left = mid + 1;
			k = k - 2;//减两位
		}
		else
		{
			if (mid <= n)
				return mid;//相等贼说明mid是查找到的
			else
				return n;//大于n说明找到补全的那部分了，此时返回n，n和补全的对应值相同
		}

	}
}
```

> 扩容是为了避免有时后会出现mid超出n的情况

#### 线性索引查找：

当数据太庞大时，保证按关键字有序的时间代价是非常昂贵的，所以这种数据通常按先后顺序存储

方法：**索引**（为了加快查找速度的数据结构）——把一个关键字与它对应的记录相关联的过程

索引分为线性，树形，多级索引，这里重点介绍线性索引技术

线性索引：**将索引项集合组织为线性结构，也叫索引表**

三种线性索引：稠密索引，分块索引，倒排索引

##### 稠密索引：

==将数据集中的每一个记录对应一个索引项==

因为索引要应对成千上万的数据，所以索引项一定是按照关键码有序的排列，这样我们查找关键字时可以用有序查找提高效率

但也会有缺点，如果数据非常庞大，上亿，意味索引也需要占很大内存，查找性能反而大大下降

##### 分块索引：

对数据进行分块，然后每一块建立一个索引

分块满足两个条件：

> 块内无序：块内记录不要求有序，因为会付出大量时间和空间的代价
>
> 块间有序：保证查找时的效率

![分块索引](C:\Typora\picture\分块索引.png)

 n个记录分为m块，每块t条记录，n = m × t

ASL~w~ = L~b~ + L~w~ = (m+1)/2 + (t+1)/2 = (n/t + t)/2 +1

观察式子可以得到，当m  = t 的时候最小最后得到ASL~w~ =n^1/2^

比O(n)要效率高，但还是不如二分的O(logn), 所以我们使块间的编号有序，这样就可以用二分法，块内数据不要求有序

##### 倒排索引：

![倒排索引举例一](C:\Typora\picture\倒排索引举例一.png)

![倒排索引举例一](C:\Typora\picture\倒排索引举例二.png)

通用结构是：次关键码 + 记录表号

**其中记录表号储存具有相同次关键字的所有记录的记录号（可以是指向记录的指针或记录的主关键字）**

由属性来确定记录的值

优点：查找记录非常快

缺点：记录号不定长，比较难维护

事实上，搜索技术非常复杂，想要成为搜索引擎的工程师还有很远的路要走

#### 二叉排序树☀️☀️☀️：

十分有用啊，在查找和删除中都有一个好的时间复杂度

二叉排序树（Binary Sort Tree）：或者是一颗空树，或者是具有以下性质的二叉树

> 若左子树不空，则左子树上的所有结点的值均小于它的根结点的值
>
> 若右子树不空，则右子树上的所有结点的值均大于它的根结点的值
>
> 左右子树分别是二叉排序树

##### 二叉排序树查找操作：

```c++
//递归查找二叉排序树中是否存在key
//指针f指向T的双亲，其初始调用值为NULL
//查找成功，则p指向改数据元素的结点，返回TRUE
//查找失败p指向查找路径上访问的最后一个结点并返回FALSE
int searchBTS(BiTree T, int key, BiTree f, BiTree* p)
{
	if (!T)//查找不成功
	{
		*p = f;//指向访问的最后一个结点
		return FALSE;
	}
	else if (key == T->data)
	{
		*p = T;//指向找到的结点
		return TRUE;
	}
	else if (key < T->data)
	{
		return searchBTS(T->lchild, key, T, p);//小于在左子树查找
	}
	else
	{
		return searchBTS(T->rchild, key, T, p);//大于在右子树查找
	}
}
```

递归查找，较为简单

##### 二叉排序树插入操作：

```c++
//二叉树的插入操作
int insetBST(BiTree& T, int key)
{
	BiTree p, s;
	if (!searchBTS(T, key, NULL, &p))//查找不成功
	{
		s = new BiTNode;
		s->data = key;
		s->lchild = s->rchild = NULL;
		if (!p)
		{
			T = s;//如果为空二叉排序树
		}
		else if (key < p->data)
		{
			p->lchild = s;//小则插左边
		}
		else
		{
			p->rchild = s;//大则插右边
		}
		return TRUE;
	}
	else
	{
		return FALSE;//树中已有该结点，不再插入
	}
}
```

这里考虑的情况是序列中没有相同的数的情况，假如没有找到，不存在说明为空树，创建根节点，存在的话，==小于插左节点，大于插右结点（这里为什么这么绝对？多想一下就可以得知，插入的位置其实就是查找函数判断为空的那个位置）==

##### 二叉排序树删除操作：

请神容易送神难，删除的时候情况就多变了起来

情况1️⃣ ：删除的结点只有左子树或右子树

这时候就是==子承父业==，删除后把左或右结点连上就行

情况 2️⃣：删除的结点既有左子树又有右子树（较复杂）

![二叉排序树的删除](C:\Typora\picture\二叉排序树的删除.png)

精髓就是找到左右子树中可以顶替被删除结点的数据

如何找？

找被删除结点的左右邻值，如上图47，找**左子树最大值，右子树最小值**，这样肯定就继续满足定义了，左子树中所有小于父结点，右子树中所有大于父结点

```c++
int BiDelete(BiTree& p)
{
	BiTree q, s;
	if (!p->lchild)//左子树为空则直接连右子树
	{
		q = p;//记录要删除的结点
		p = p->rchild;//右子树连接
		free(q);//释放结点
	}
	else if (!p->rchild)//同上
	{
		q = p;
		p = p->lchild;
		free(q);
	}
	else//左右子树均不为空
	{
		q = p;
		s = p->lchild;
		while (s->rchild)//此处转左，所以循环找右可以找到左子树最大值，转右方法一致
		{
			q = s;//q最后记录的是要代替被删结点的双亲
			s = s->rchild;
		}
		p->data = s->data;//代替点的数据域全拷贝进被删结点的位置
		if (q != p)//找到的q不是要被删的结点时连右子树
		{
			q->rchild = s->lchild;
		}
		else//假如找到的q还在指向被删结点时连左子树
		{
			q->lchild = s->lchild;
		}
		return TRUE;
	}
}
int deleteBST(BiTree& T, int key)
{
	if (!T)//没有找到要删除的值
	{
		return FALSE;
	}
	else
	{
		if (key == T->data)
		{
			return BiDelete(T);
		}
		else if (key < T->data)
		{
			return deleteBST(T->lchild, key);
		}
		else
		{
			return deleteBST(T->rchild, key);
		}
	}
}

```



总结：二叉排序数是以连接的方式储存，查找时经历的结点个数最小是1，最大不会超过深度

![二叉排序树对比](C:\Typora\picture\二叉排序树对比.png)

上图体现了构建二叉排序树的策略，就是使二叉树尽量深度较小，也就是深度与完全二叉树一致，上左图也不是十分平衡，上右图就是极端情况

时间复杂度：构造得好相当于二分查找O(logn)，不好则相当于遍历查找，为O(n)

那么我们该如何构建一个平衡的二叉排序树呢？继续往后看

#### 平衡二叉树（AVL树）

是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1（**高度平衡的二叉排序树**）

**平衡因子BF**：二叉树上结点的左子树深度减去右子树深度的值，根据上面的定义，平衡因子只可能是-1，0，1

平衡二叉树的判断：

![判断是否为AVL树](C:\Typora\picture\判断是否为AVL树.png)

图二表示：首先必须是排序二叉树

图三表示：58的对应结点的左子树的高度为2，而右子树为空，BF不满足

图一图四就是AVL树

**最小不平衡子树**：距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树

![最小不平衡子树](C:\Typora\picture\最小不平衡子树.png)

上图中，新插入的为37，离它最近的平衡因子绝对值大于1的结点是58，所以以58为根的树为最小不平衡树

##### 平衡二叉树实现原理：

先按构造排序二叉树的思路插入结点，**然后检查是否因插入破环了平衡性，若是，找出最小不平衡树，最后在满足二叉排序树特征的条件下调整 **，得到新的平衡子树

核心思想是对最小不平衡树进行及时的处理——**左旋、右旋**

旋转的条件：最小不平衡根的BF绝对值大于1，并且此时**对应（左旋时对应右子结点，右旋时对应左子结点）**的子结点同号

![平衡二叉树原理](C:\Typora\picture\平衡二叉树原理.png)

此时根为-2，对应子结点为-1，满足条件，旋转一次后则成功

![平衡二叉树原理二](C:\Typora\picture\平衡二叉树原理二.png)

新加入9后，7为-2，10为1，不满足异号，旋转之后就会出现不满足二叉排序树的情况，此时就会发现旋转一次已经不能满足了

但总有大佬找到解决方法——先对对应结点为根的子树进行一次相反方向旋转（比如此时最终是要左旋，我们就要先右旋）⛄⛄⛄⛄⛄⛄⛄⛄

以上举例是BF为-2时，==如果为2，只是旋转方向会相反，其他判断都是一致的==

从插入位置的不同角度也可以判断应该进行什么旋转操作：
**LL调整(右单旋调整)：**（在左孩子的左子树上插入导致不平衡的调整）

![AVL_LL](C:\Typora\picture\AVL_LL.png)

只需要将BF改变了的结点进行一次右旋，注意旋转不是完全的线连线不断的，还是得保证还是排序二叉树，上面旋转时14到了24的左子树上（==原根的左子树的右子树移到后根的右子树的左子树上去==）

> 记的方法：原根旋转后，一定会空出左子树，想到要把这补齐就好了，补齐选取的肯定是不参与旋转的，也就是BF没有变的左孩子的右子树

**RR调整(左单旋调整)：**（在右孩子的右子树上插入导致不平衡的调整）

![AVL_RR](C:\Typora\picture\AVL_RR.png)

与LL步骤一致，只需要将上面的文字中的左换右，右换左就行

**LR调整：**（在左孩子的右子树上插入导致不平衡）

![AVL_LR](C:\Typora\picture\AVL_LR.png)

我们可以看到旋转一次是到不了平衡的，这里分了两步，首先进行一次左旋，参与的是（13，14，15）——==就是新插入结点到根的左孩子路径上的点==，旋转时要记住该断就要断（**比如这里，转完后13肯定没有右子树，我们要看14有没有左子树，没有就算了**），再进行第二次的右旋，参与的是（24，14，13），其实到这发现☀️哎，这不是又是一次LL调整吗☀️，确实，我们只是多做了一步变换为了LL

**RL调整：**（在右孩子的左子树上插入导致不平衡）

![AVL_RL](C:\Typora\picture\AVL_RL.png)

与LR步骤一致，只需要将上面的文字中的左换右，右换左就行

AVL调整其实就需要记住三点：

1️⃣ 旋转不是不断连接线，而是要看旋转前的根结点缺了啥，该补啥

2️⃣ 主要参与结点是插入结点到最近的BF出问题的点路径上的点，单旋（不需插入结点参与），变为单旋之前的旋转（不需要最近的BF出问题的结点参与）

3️⃣每插入一个就要判断和调整一次，将差错扼杀在摇篮里

##### 平衡二叉树实现算法：

道理我都懂，但鸽子为什么这么大（bushi）👏 👏 ，代码完全掌握可能还需要些时日

代码实现：

```c++
#define FALSE 0
#define TRUE 1
typedef struct BiTNode
{
	int data;
	int bf;//增加平衡因子域
	struct BiTNode* lchild, * rchild;
}BiTNode, *BiTree;
#define LH +1 //左高
#define EH 0  //等高
#define RH -1 //右高
//左旋函数
//传入旋转树的根p，函数结束时p指向新的根
void lRotate(BiTree& p)
{
	BiTree R;
	R = p->rchild;//L先指向p的右子树
	p->rchild = R->lchild;//这里就表现了旋转是要断连接线的
	R->lchild = p;
	p = R;//p指向新的结点
}

//右旋函数
//传入旋转树的根p，函数结束时p指向新的根
void rRotate(BiTree & p)
{
	BiTree L;
	L = p->lchild;//L先指向p的左子树
	p->lchild = L->rchild;//这里就表现了旋转是要断连接线的
	L->rchild = p;
	p = L;//p指向新的结点
}
//对以指针T所对结点为根的二叉树左平衡处理
//结束后T指向的是新的根结点
void leftBalance(BiTree& T)
{
	BiTree L, Lr;
	L = T->lchild;//L指向左子树
	switch(L->bf)//检查左子树的平衡度
	{
	case LH://插入在左孩子的左子树上,单右旋
		T->bf = L->bf = EH;
		rRotate(T);
		break;
	case RH://插入在左孩子的右子树上，LR旋
		Lr = L->rchild;//Lr指向T左孩子的右子树根
		switch (Lr->bf)
		{
		case LH:
			T->bf = RH;
			L->bf = EH;
			break;
		case EH:
			T->bf = L->bf = EH;
			break;
		case RH:
			T->bf = EH;
			L->bf = LH;
			break;
		}
		Lr->bf = EH;
		lRotate(T->lchild);//先对T的左子树左旋，这里传参不能传L，L虽然和T->lchild值一样但位置不一样，不会改变整个树
		rRotate(T);//对T右旋
	}
}

//对以指针T所对结点为根的二叉树右平衡处理
//结束后T指向的是新的根结点
void rightBalance(BiTree& T)
{
	BiTree R, Rl;
	R = T->rchild;//L指向右子树
	switch (R->bf)//检查右子树的平衡度
	{
	case RH://插入在右孩子的右子树上,单左旋
		T->bf = R->bf = EH;
		lRotate(T);
		break;
	case LH://插入在右孩子的左子树上，RL旋
		Rl = R->lchild;//Rl指向T右孩子的左子树根
		switch (Rl->bf)
		{
		case LH:
			T->bf = EH;
			R->bf = RH;
			break;
		case EH:
			T->bf = R->bf = EH;
			break;
		case RH:
			T->bf = LH;
			R->bf = EH;
			break;
		}
		Rl->bf = EH;
		rRotate(T->rchild);//先对T的右子树右旋
		lRotate(T);//对T左旋
	}
}

//若在平衡的二叉树中不含和e相同的关键字结点，插入
//数据元素为e的新结点并返回1，否则返回0，若插入后失衡
//我们需要进行平衡旋转，taller反映T长高与否
int InsertAVL(BiTree& T, int e, bool *taller)
{
	if (!T)//为空说明此处是叶子结点的左右孩子，可以插入
	{
		T = new BiTNode;
		T->bf = EH;
		T->data = e;
		T->lchild = T->rchild = NULL;
		*taller = TRUE;
	}
	else//树不为空
	{
		if (e == T->data)
		{
			*taller = FALSE;
			return FALSE;
		}
		if (e < T->data)//左子树中搜索
		{
			if (!InsertAVL(T->lchild, e, taller))//未插入
			{
				return FALSE;
			}
			if (*taller)
			{
				switch (T->bf)//检查T的平衡度
				{
				case LH://原来左子树比右子树高，需要平衡处理
					leftBalance(T);
					*taller = FALSE;
					break;
				case EH://原来左右子树等高,现在因为左子树增高而增高
					T->bf = LH;
					*taller = TRUE;
					break;
				case RH://原来右子树比左子树高，现在等高
					T->bf = EH;
					*taller = FALSE;
					break;
				}
			}
		}
		else
		{
			if (!InsertAVL(T->rchild, e, taller))//未插入
			{
				return FALSE;
			}
			if (*taller)
			{
				switch (T->bf)//检查T的平衡度
				{
				case LH://原来左子树比右子树高，现在等高
					T->bf = EH;
					*taller = FALSE;
					break;
				case EH://原来左右子树等高,现在因为左子树增高而增高
					T->bf = RH;
					*taller = TRUE;
					break;
				case RH://原来右子树比左子树高，需要平衡处理
					rightBalance(T);
					*taller = FALSE;
					break;
				}
			}
		}
	}
	return TRUE;
}
```

还是递归插入，插入成功后，会是·	

查并更改路径上结点的bf值，发现不对劲及时平衡调整，令人感叹 ✈️ ✈️ ✈️ ✈️ ✈️

时间复杂度：==查找，插入，删除都为O(logn)==，是比较理想的动态查找表算法

#### 多路查找树（B树）：

定义：**每个结点的孩子数可以多于两个，且每一个结点可以存储多个元素**

##### 2-3树：

**每一个结点都具有两个孩子（2结点）或三个孩子（3结点）**

2结点：包含一个元素和两个孩子（或没有孩子）==与二叉排序树不同之处，有孩子则孩子必须都存在==

3结点：包含一小一大两个元素和三个孩子（或没有孩子）==一样，有孩子则孩子必须都存在==

![2-3树](C:\Typora\picture\2-3树.png)

> 2结点：左右孩子排布与二叉排序树一致
>
> 3结点：左子树比小数据小，中间子树大于小数据小于大数据，右子树大于大数据
>
> 可以看出：因为孩子必须存在，导致2-3树的层次一致

1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 0️⃣

**插入**：
1️⃣空树直接插

2️⃣插入到2结点，只需要将2升级成3

![2-3插入1](C:\Typora\picture\2-3插入1.png)

3️⃣插入到3结点，分成两种情况

​	1️⃣ 自己是3结点，双亲是2结点，双亲升级3结点挤走中位结点，剩下两个一个摆中，一个摆左或右

![2-3插入2](C:\Typora\picture\2-3插入2.png)

​	2️⃣ 自己是3结点，双亲也是3结点，双亲降级为2结点，再选出一个元素作为新的2结点，连在合适的位置

![2-3插入3](C:\Typora\picture\2-3插入3.png)

再看一幅图：

![2-3树长高](C:\Typora\picture\2-3树长高.png)

看得到，2-3树深度增加的条件是，根结点被拆分

**删除**：
1️⃣位于3结点直接删

2️⃣位于2结点，分四种情况

​	1️⃣ 双亲为2结点且拥有一个三结点的孩子，类似于平衡时的旋转

![2-3删除1](C:\Typora\picture\2-3删除1.png)

​	2️⃣ 双亲2为结点，右孩子也是2结点

![2-3删除2](C:\Typora\picture\2-3删除2.png)

对整棵树变形，讲右孩子变为3结点之后再旋转

​	3️⃣双亲为3结点

![2-3删除3](C:\Typora\picture\2-3删除3.png)

双亲拆分

​	4️⃣树为满二叉树形态

![2-3删除4](C:\Typora\picture\2-3删除4.png)

层数减少，部分2结点合并成3结点

3️⃣位于非叶子结点的分支结点，按照中序遍历后得到前驱后继，考虑用他们补位

![2-3删除5](C:\Typora\picture\2-3删除5.png)

到这，发现，情况也太多了，代码不是我现在能实现的，这代码难度较高，需要更深刻的体会

##### 2-3-4树：

2-3树的概念拓展，包括了4结点的使用

4结点：包含小中大三个元素和四个孩子（或没有孩子）数据摆放与3结点类似，两个数据之间的子树中的元素大小在两数之间

插入：

![2-3-4插入](C:\Typora\picture\2-3-4插入.png)

删除：

![2-3-4删除](C:\Typora\picture\2-3-4删除.png)



##### B树（B-tree）

本节重点，看似我们才开始讲，其实我们前面一直在讲B树

定义：**平衡的多路查找树**

2-3树，2-3-4树时B树的特例

**B树的阶（order）：结点最大的孩子数目**，2-3树是3阶B树，2-3-4树是4阶B树

![B树](C:\Typora\picture\B树.png)

m阶B树具有的属性

1️⃣ 根结点不是叶结点，其至少有两棵子树

2️⃣非根的分支结点都有k-1个元素和k个孩子，每一个叶子结点都有k-1个元素

3️⃣所有叶子结点都位于同一层次

B树的查找：

过程：顺指针查找结点和在结点中查找关键字的交叉过程

B树的插入和删除：

与2-3树类似，只不过阶数可能很大

n个关键字的m阶B树，最坏情况是要查几次？

==此处[m/2]的意义还没有理解透==

附上B树结点相关博客，还需继续学习[(B-树关键字个数计算_DrCrypto的博客-CSDN博客_b树关键字个数](https://blog.csdn.net/u011240016/article/details/53149389?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165114885716782390560435%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165114885716782390560435&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-53149389.142^v9^pc_search_result_control_group,157^v4^control&utm_term=b%E6%A0%91%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%AA%E6%95%B0&spm=1018.2226.3001.4187)

![B树查找次数](C:\Typora\picture\B树查找次数.png)



##### B+树

弥补B树的缺陷，严格意义上来讲不是树结构，为了解决B树上所有元素的遍历（因为如果按二叉树的方法来遍历，效率实在低下）

![B+树](C:\Typora\picture\B+树.png)

B+树：在原有的B树上，加上新的元素组织方式，这就是B+树

![B+树2](C:\Typora\picture\B+树2.png)

B树中，一个元素出现一次，而B+树中，出现过的分支元素会在他们中序后继结点中再次列出（如图灰色部分）

m阶B+树与B树的差异

> 有n棵子树的结点中包含有n个关键字
>
> 所有==叶子结点==包含全部关键字线索，及指向这些关键字记录的指针，叶子结点本身依关键字自小而大顺序连接
>
> 所有分支结点可以看成索引，结点中仅含有其子树中的最大（或最小关键字）

最后一句好好理解，就是说除了叶子结点，前面的结点都只是为了找到叶子结点（看成索引的理解），通过索引找到特定的值后按叶子结点的顺序连接往后遍历即可，例：我们要调查18~22岁的学生人数，我们从根结点出发找到18，再按叶子结点往后找，直到22

#### 散列表（哈希表）：

##### 散列表查找（哈希表）概述

哈希表（Hash Table），之前就一直被这个名字吓到，一直以为又是哪个伟大科学家搞出来的及其难懂的东西，后来发现不过是由Hash直译过来罢了，**哈希表就是散列表**

散列表定义：

通过某个函数f找到储存位置

​				       ==储存位置=f（关键字）==

这样我们就可以通过查找关键字不需要比较就可以获得记录的储存位置，这就是散列技术

**散列技术**：记录的储存位置和它的关键字之间建立一个确定的对应关系f，使得每一个关键字key对应一个存储位置f(key)==既是一种储存方法，也是一种查找方法==

**散列函数（哈希函数）**：上面的f就是

**散列表（哈希表）**：采用散列技术将记录存储在一块连续的储存空间

散列表查找步骤：

两步：

一、存储时，通过散列函数计算散列地址，按散列地址储存

二、查找时，通过**同样的散列函数**计算散列地址，按散列地址访问

适合的求解问题是：查找与给定值相等的记录

**冲突**：两个关键字key1、key2，key1 ≠ key2，但f(key1) = f(key2)

**同义词**：上述中的key1和 key2就是这个散列函数的同义词

##### 散列函数的构造方法：

要求：计算简单，散列地址分布均匀

1️⃣直接定址法

取关键字的某个线性函数值为散列函数：==f(key) = a×key + b==

优点：简单均匀，不会冲突   

缺点：需事先得知分布情况，查找表较小且连续

2️⃣数字分析法

抽取——使用关键字的一部分来计算储存位置

优点：适合处理关键字位数较大的情况

缺点：事先得知关键字分布且关键字的若干位分布较均匀

3️⃣平方取中法

将关键字平方在抽取中间的几位

优点：适合不知道关键字分布

缺点：位数不能太大

4️⃣折叠法

将关键字从左到右分割成位数相同的几部分（最后一部分位数不够时可以短一点），不同部分相加，再按散列表的表长，决定从结果中取几位

优点：不需要事先知道关键字分布，适合关键字较多的情况

5️⃣除留余数法

**这是最常用的方法**

散列表长为m时的公式：==f(key) = key mod p（p <=m）==

不一定是直接对关键字取模，也可以是关键字折叠平方后再取模

p取何值？经过前辈们的努力，p通常为小于或等于m（最好接近m）的质数或不包含小于20质因子的合数

6️⃣随机数法

选择一个随机数，取关键字的随机函数值为散列地址：f(key) = random(key)

优点：适合关键字长度不等

总结：使用哪一个散列函数的考虑因素

> 计算散列地址所需时间
>
> 关键字长度
>
> 散列表大小
>
> 关键字分布情况
>
> 记录查找的频率

##### 处理散列冲突的方法：

再健康的人也会生病，散列冲突也是不可避免的，前面的散列函数是为了减少冲突，接下来是冲突出现如何解决

1️⃣开放定址法

**一旦发生冲突，去寻找下一个空的散列地址，只要散列表足够大，散列地址总能找到并记录**

⚡公式：**f~i~(key) = (f(key) + d~i~ MOD m ( d~i~ = 1,2,3,……m-1))**

以上这个公式解决冲突的开放定址法称为==线性探测法==

**堆积**：本来不是同义词却要争夺一个地址的情况

⚡公式：**f~i~(key) = (f(key) + d~i~ MOD m ( d~i~ = -1^2^,1^2^,-2^2^,2^2^,……-q^2^,q^2^,q <=m/2))**

以上这个公式解决冲突的开发定址法称为==二次探测法==（可以双向寻找困难空位置，**平方也可以不让关键字聚集在某一块区域**）

⚡公式：**f~i~(key) = (f(key) + d~i~ MOD m ( d~i~是一个随机数列))**

以上这个公式解决冲突的开发定址法称为==随机探测法==（d~i~采用随机函数得到）

那怎么保证储存和查找的d~i~序列相等？

这个随机函数其实是伪随机函数，只要我们给同一个种子，数列就会相同

2️⃣再散列函数法

⚡公式：**f~i~(key) = RH~i~(key)(i = 1,2……k)**

RH为不同的散列函数（你可以把之前说的所有方法都用上），每当发生冲突，我们就换一个散列函数计算

3️⃣链地址法

**同义词子表**所有关键字为同义词的记录储存在一个单链表中

散列表中只储存头指针（不是头结点）

![链地址举例](C:\Typora\picture\链地址举例.png)

 4️⃣公共溢出区法

所有冲突的单独存入到溢出表中，基本表通过散列函数寻址，溢出表进行顺序查找（冲突少的情况下，查找性能较高）

##### 散列表查找实现：

```c++
#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12//定义数组长度
#define NULLKEY -32768
typedef struct HashTable
{
	int* elem; //数据元素储存址，动态分配数组
	int count;//当前数据元素个数
}HashTable;
int m = 0;//列表表长，全局变量

//初始化列表
void initHashTable(HashTable* H)
{
	int i = 0;
	m = HASHSIZE;
	H->count = m;
	H->elem = new int[m];
	for (i = 0; i < m; i++)
	{
		H->elem[i] = NULLKEY;
	}
}
//散列函数，可以有多种选择
int Hash(int key)
{
	return key % m;//除留余数法
}

//输入关键字进散列表
void insertHash(HashTable* H, int key)
{
	int addr = Hash(key);
	while (H->elem[addr] != NULLKEY)//不为空则冲突
	{
		addr = (addr + 1) % m;//开放寻址发起的线性探测
	}
	H->elem[addr] = key;//空位存关键字
}

//散列表查找函数
int searchHash(HashTable H, int key, int* addr)
{
	*addr = Hash(key);//求散列地址
	while (H.elem[*addr] != key)//不为关键字则冲突
	{
		*addr = (*addr + 1) % m;//线性探测
		if (H.elem[*addr] == NULLKEY || *addr == Hash(key))
		{
			return UNSUCCESS;
		}
	}
	return SUCCESS;
}

```

性能分析：**如果没有冲突**，散列表是本章介绍的所有查找中效率最高的，时间复杂度为O(1)，但是冲突不可避免

散列函数的平均查找长度取决于；

> 一：散列函数是否均匀
>
> 二：处理冲突的方法（平均查找性能：线性探测法 < 二次探测法 < 链地址法）
>
> 三：散列表的装填因子（填入表中记录的个数/散列表长度），所以通常我们将散列表的空间设置比查找集合大，虽然浪费一定的空间，但查找效率明显提升，这是值得的

### 排序：

#### 排序的基本概念与分类：

**排序**：假设含有n个记录的序列为{r1，r2，r3……rn}，相应的关键字为{k1，k2，k3……kn}，需确定1，2，……，n的一种排列p1，p2……pn，使其相应的关键字满足k~p1~<=k~p2~<=……<=k~pn~(非递减或分递增) 关系，使得序列成为一个按关键字有序的序列{r~p1~ <= r~p2~ <=……r~pn~}

**排序的稳定性**：假设k~i~ = k~j~，排序前的序列中r~i~领先于r~j~，如果排序后仍有r~i~领先于r~j~，则称所用的排序方法是稳定的，反排序后r~j~ 领先e~i~，则称排序方法是不稳定的![排序的稳定性](C:\Typora\picture\排序的稳定性.png)

**内排序和外排序**

内排序：在排序过程中，待排序的所有记录**全被放置在内存中**

外排序：由于排序的记录个数太多，不能同时放置在内存，**整个排序过程需要内外存之间多次交换数据才能进行**

我们主要介绍内排序，内排序的性能受三个方面影响

> 1、时间性能：排序算法的时间开销是衡量算法好坏的最重要标志。排序中的主要操作是比较和移动（所以高效的算法要尽量减少关键字比较次数和减少记录的移动次数）
>
> 2、辅助空间：存放待排序所占用的储存空间和执行算法所需要的其他的储存空间
>
> 3、算法的复杂度：不是指时间复杂度，是算法本身的复杂程度

根据排序过程：插入排序，交换排序，选择排序和并归排序

按算法的复杂发分为两类：简单算法：冒泡排序、简单选择排序、直接插入排序。改进算法：希尔排序，堆排序、并归排序、快速排序

> 补充：基数排序

####   ✨八大排序 ✨：

![八大排序](C:\Typora\picture\八大排序.png)

排序用的结构体和函数

```c++
#define MAXSIZE 10  //要排序数组的最大指，根据需要修改

typedef struct SqList 
{
	int r[MAXSIZE + 1];//用于储存需要排序的数组，r[0]可以用作哨兵，数据从下标1开始存
	int length;//记录顺序表的长度,包括下标为0的元素
};

//交换函数
void swap(SqList& L, int i, int j)
{
	int temp = L.r[i];
	L.r[i] = L.r[j];
	L.r[j] = temp;
}

```



##### 冒泡排序（Bubble Sort）：

基本思想：==两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止==

最简单的排序实现：

算法效率极低

```C++
//对顺序表L作交换排序（冒泡排序初级版）
void bubbleSort0(SqList& L)
{
	int i, j;
	for (i = 1; i < L.length; i++)
	{
		for (j = i + 1; j < L.length; j++)
		{
			if (L.r[i] > L.r[j])
			{
				swap(L, i, j);
			}
		}
	}
}
```

正宗的冒泡排序：

比第一种稍微改进了一点，数据像泡泡一样不断上浮，不会出现原本在前面的小的数字被交换到最后的情况

```c++
//对顺序表L作交换排序（冒泡排序正宗版）
void bubbleSort(SqList& L)
{
	int i, j;
	for (i = 1; i < L.length; i++)
	{
		for (j = L.length - 1; j > i; j--)
		{
			if (L.r[j] > L.r[j - 1])
			{
				swap(L, j, j - 1);
			}
		}
	}
}
```

冒泡排序优化⭐⭐⭐：

冒泡排序还能被继续优化吗？还能，比如{2，1，3，4，5，6，}，在第一个和第二个交换之后发现已经有序了，我们何必再继续循环呢，所以我们设置一个标志，当i不变的某一次循环中一次都没有交换，说明已经有序

```c++
//对顺序表L作交换排序（冒泡排序改进版）
void bubbleSort2(SqList& L)
{
	int i, j;
	bool flag = true; //true代表还需进行下一次循环
	for (i = 1; i < L.length && flag; i++)
	{
		flag = false;
		for (j = L.length - 1; j > i; j--)
		{
			if (L.r[j] > L.r[j - 1])
			{
				swap(L, j, j - 1);
				flag = true;
			}
		}
	}
}
```

复杂度分析：最好情况说n-1比较，最差是n(n-1)/2，所以时间复杂度为==O(n^2^)==

##### 简单选择排序（Simple Selection Sort）：

**略优于冒泡排序**

基本思想：==通过n-i次关键字的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换之==

```c++
//简单交换排序
void selecrSort(SqList& L)
{
	int i, j;
	for (int i = 1; i < L.length; i++)
	{
		int min = i;//i先赋值给min
		for (j = i + 1; j < L.length; j++)
		{
			if (L.r[j] < L.r[min])
			{
				min = j;
			}
		}
		if (min != i)
		{
			swap(L, min, i);
		}
	}
}
```

时间复杂度分析：最好最坏情况比较次数一样多n(n-1)/2次，交换次数最好0次，最坏n-1次，时间复杂度==O(n^2^)==

##### 直接插入排序（Straight Insertion Sort）:

**优于冒泡排序和简单选择排序**

基本思想：==将一个记录插入到一个已经排序好的有序表中，从而得到一个新的、记录数增1的有序表==

```c++
//直接插入排序
void insertSort(SqList& L)
{
	int i, j;
	for (i = 2; i < L.length; i++)
	{
		if (L.r[i] < L.r[i - 1])//需要将L.[i]插入到有序子表中
		{
			L.r[0] = L.r[i];//设置哨兵
			for (j = i - 1; L.r[j] > L.r[0]; j--)
			{
				L.r[j + 1] = L.r[j];//记录后移
			}
			L.r[j + 1] = L.r[0];//插入回正确位置
		}
	}
}
```

时间复杂度分析：最好情况有比较没移动时间复杂度O(n)，最坏情况比较(n+2)(n-1)/2次，移动(n+4)(n-1)/2次，平均比较和移动次数是n^2^/4,时间复杂度为==0(n^2^)==

##### 希尔(Shell Sort)排序：

**优于之前的三个排序**

基本思想：==找到合适的增量，跳跃着使用插入排序，一个增量的插入结束之后，增量缩小，得到基本有序序列，最后一次一定是间隔为1的插入排序==

是D.LShell提出的排序算法，在此之前排序的时间复杂度基本都是O(n^2^)，希尔排序是突破这个时间复杂度的第一批算法之一

引入：直接插入排序中，某些时候的效率是很高的（记录基本有序、记录数据较少），这个条件比较苛刻，**没有条件创造条件**来增加效率

基本有序：**小的关键字基本在前面，大的基本在后面，不大不小的基本在中间**，例：（2，1，3，6，4，7，5，8，9）

问题就在这，我们分割待排序记录的目的是减少待排序记录的个数，使序列向基本有序发展——采用跳跃分割的策略

**跳跃分割：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行插入排序后得到的结果是基本有序而不是局部有序**

代码实现：

```c++
//希尔排序
void shellSort(SqList& L)
{
	int i, j;
	int increment = L.length - 1;//因为这里把r[0]也算进去了
	do
	{
		increment = increment / 3 + 1;//不一定是这个表达式
		for (i = increment + 1; i < L.length; i++)//从incremen+1开始
		{
			if (L.r[i] < L.r[i - increment])//需要插入
			{
				L.r[0] = L.r[i];//设置哨兵
				for (j = i - increment; j > 0 && L.r[0] < L.r[j]; j -= increment)
				{
					L.r[j + increment] = L.r[j];//后移
				}
				L.r[j + increment] = L.r[0];//哨兵插回对应位置
			}
		}
	} while (increment > 1);//其实就是increment等于1的时候结束
}
```

![希尔排序](C:\Typora\picture\希尔排序.png)

同一颜色是要进行插入排序的子序列

时间复杂度分析：最主要通过增量实现跳跃式移动，**选增量是关键**，究竟怎么选取最好是一个数学未解之谜，大量研究表明增量序列为dlta[k] = 2^t-k+1^-1效果不错（**最后一个增量值一定等于1**），时间复杂度为O(n^3/2^)

##### 堆排序(Heap Sort)：

**堆：具有下列性质的==完全二叉树==：每个结点的值都大于等于其左右孩子结点的值，称为大顶堆，或者每个结点的指都小于或等于其左右孩子结点的值，称为小顶堆**

![堆结构](C:\Typora\picture\堆结构.png)

​			      大顶堆                                                  小顶堆

堆排序：利用堆

基本思想：==待排序序列构造成一个大顶堆（用大顶堆举例），此时整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。反复执行，便能得到一个有序序列==

![堆排序一](C:\Typora\picture\堆排序一.png)

![堆排序二](C:\Typora\picture\堆排序二.png)

注意：堆是用数组实现的，只是位置关系可以用二叉树表现而已，换句话说，完全二叉树就是数组

代码实现：

```c++
//堆排序
//L.[s...m]中记录的关键字除L.[s]之外都满足堆定义
//调整L.[s...m]，使之成为一个堆
void heapAdjust(SqList& L, int s, int m)//此函数十分关键
{
	int temp, j;
	temp = L.r[s];//储存要调整子树的根结点
	for (j = s * 2; j <= m; j *= 2)//m是堆的最后一位，不可能超过
	{
		if (j < m && L.r[j] < L.r[j + 1])
		{
			j++;//说明右子树比左子树大，j要指向右结点 
		}
		if (temp >= L.r[j])
		{
			break;//说明根结点已经最大，不需要继续找
		}
		L.r[s] = L.r[j];
		s = j;
	}
	L.r[s] = temp;//插入 
}

void heapSort(SqList& L)
{
	int i;
	for (i = (L.length - 1) / 2; i > 0; i--)//有子树的结点才需要调整
	{
		heapAdjust(L, i, L.length - 1);
	}

	for (i = L.length - 1; i > 1; i--)
	{
		swap(L, 1, i);//将堆顶记录和当前未经排序子序列的最后一个记录交换
		heapAdjust(L, 1, i - 1);//未排子序列调整为大顶堆
	}
}
```

这个代码不是一眼就能看懂，所以在这里分析一下

首先分析堆调整函数：传入待排序列L，带调整子树的根s，未排子序列的最后一位m（用于判断循环是否继续）

一：首先把根节点的值储存，因为在后面会把找到的最大值直接填入

二：完全二叉树的左孩子是2i，右孩子是2i+1，每次需要找出子树中的最大值来调整

三：最后要将最大值填回根结点位置

接下来是堆排序函数：

==堆调整的时候一定是从下往上，从右往左，转换到数列中就是找到所有需要调整的树倒叙调用堆调整函数==

一：第一个for循环是先将未经任何处理的序列变为堆，为什么是长度的一半呢？![堆调整](C:\Typora\picture\堆调整.png)

可以看出**有孩子的结点**需要调整的

二：第二个for循环：首先就要把堆顶拿走（拿出最大值），代码体现为交换第一和待排子序列的最后一个，这时候其实拿出的最大值已经到了正确的位置，此时我们把待排序列减一，重新调整成堆，循环n-1次

时间复杂度分析：最初构建堆的时间复杂度是O(n)，正式排序时，第i次读取记录重建堆要用的O(logi)，并且需要取n-1次堆顶记录，因此时间复杂度为==O(nlogn)==，堆排序对原始记录的排序不敏感，最好，最坏，平均时间复杂度一样

因为初始化堆的比较次数较多，所以不适合待排序列个数较少的情况

##### 归并排序（Merging Sort）：

归并定义：两个或两个以上的有序表组合成一个新的有序表

基本思想：==假设有n个记录，先看成每个子序列是1的n个有序子序列，然后两两归并，得到[n/2]个长度为2或1的有序子序列；再两两归并，……如此重复，直到得到一个长度为n的有序序列，这种叫2路归并排序==（此处只介绍了2路）

![归并原理](C:\Typora\picture\归并原理.png)

代码原理图：

![归并排序算法原理](C:\Typora\picture\归并排序算法原理.png)

递归版代码实现：

```c++
void merge(int SR[], int TR1[], int i, int m, int n)
{
	int j, k, l;
	for (j = m + 1, k = i; i <= m && j <= n; k++)//两子序列的头部比较，小的放入
	{
		if (SR[i] < SR[j])
		{
			TR1[k] = SR[i++];
		}
		else
		{
			TR1[k] = SR[j++];
		}
	}
	if (i <= m)//未填完的填入
	{
      for(l = 0;l <= m-i;l++)
		TR1[k+l] = SR[i+l];
	}
	if (j <= n)//未填完的填入
	{
      for(l = 0;l <= n - j;l++)
		TR1[k+l] = SR[j+l];
	}
}
//递归实现
void mSort(int SR[] ,int TR1[] ,int s, int t)
{
	int m;
	int TR2[MAXSIZE + 1];//储存排好序之后的序列
	if (s == t)//递归出口
	{
		TR1[s] = SR[s];
	}
	else
	{
		m = (s + t) / 2;//将SR[s..m]分为SR[s..m]和SR[m+1..t]
		mSort(SR, TR2, s, m);//递归将SR[s..m]归并为有序的TR2[s..m]
		mSort(SR, TR2, m + 1, t);//递归将SR[s..m]归并为有序的TR2[s..m]
		merge(TR2, TR1, s, m, t);//将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]
	}
}
void mergeSort(SqList& L)//单独封装一个函数只是为了和之前的排序保持结构一致
{
	mSort(L.r, L.r, 1, L.length - 1);
}
```

代码解释：

一：mergeSort只是为了形式一致封装了一个函数

二： mSort参数的意义，SR未排序序列，TR1排序后的序列，s序列的起点，t序列的终点，29行是递归的出口，没到出口之前都是不断递归分割成n个为1的子序列，然后再将子序列不断两两合并（40行）

三：merge参数两个排好序的子序列合并到TR1中，for循环表示两子序列头和头比较，小的放入TR1，直到有一个子序列放完，两个if表示没有放完的子序列全部放入即可

时间复杂度分析：所有记录扫描以一遍耗费O(n)的时间，并归排序需要进行

[log~2~n]次，总的时间复杂度是==0(nlogn)==，最好最坏平均时间性能一致

空间复杂度：O(n+log~2~n)，因为递归时栈的深度为log~2~n

语句中有if(SR[i]<SR[j])说明需要两两比较，是稳定的排序算法

**非递归实现归并排序⭐**推荐⭐

```c++
void merge(int SR[], int TR1[], int i, int m, int n)
{
	int j, k, l;
	for (j = m + 1, k = i; i <= m && j <= n; k++)//两子序列的头部比较，小的放入
	{
		if (SR[i] < SR[j])
		{
			TR1[k] = SR[i++];
		}
		else
		{
			TR1[k] = SR[j++];
		}
	}
	if (i <= m)//未填完的填入
	{
		for (l = 0; l <= m - i; l++)
			TR1[k + l] = SR[i + l];
	}
	if (j <= n)//未填完的填入
	{
		for (l = 0; l <= n - j; l++)
			TR1[k + l] = SR[j + l];
	}
}
//非递归实现
void mergePass(int SR[], int TR1[], int s, int n)
{
	int i = 1;
	while (i <= n - 2 * s + 1)
	{
		merge(SR, TR1, i, i + s - 1, i + s * 2 - 1);
		i = i + 2 * s;
	}
	if (i < n - s + 1)//说明还有两个不符合间隔数组要归并
	{
		merge(SR, TR1, i, i + s - 1, n);
	}
	else//只有一个单独的数组直接写入
	{
		while (i <= n)
		{
			TR1[i] = SR[i++];
		}
	}
}
void mergeSort2(SqList& L)
{
	int* TR = new int[L.length];//申请额外的空间
	int k = 1;
	while (k < L.length - 1)
	{
		mergePass(L.r, TR, k, L.length -1);
		k *= 2;
		mergePass(TR, L.r, k, L.length - 1);
		k *= 2;
	}
}
```

非递归是直接从最小序列开始归并，不需要先拆分递归，避免了log~2~n的栈空间，避免递归时间性能也会提升，排序本身就是追求效率，所以我们**尽量用非递归实现并归算法**

##### 快速排序（Quick Sort）：

20世纪十大算法之一，你就知道它的含金量了，由图灵奖得主Tony Hoare设计，快排是他众多贡献的一个小发明

基本思想：==通过一趟排序将待排记录分割成独立的两部分，其中一部分的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的==

代码实现：

```c++
//快速排序
int partition(SqList& L,int low,int high)
{
	int pivotkey = L.r[low];//找到枢轴值
	while (low < high)
	{
		while (low < high && L.r[high] >= pivotkey)
		{
			high--;
		}
		swap(L, low, high);
		while (low < high && L.r[low] <= pivotkey)
		{
			low++;
		}
		swap(L, low, high);
	}
	return low;
}
void qSort(SqList& L, int low, int high)
{
	int pivot;
	if (low < high)
	{
		pivot = partition(L, low, high);//得到分隔的下标

		qSort(L, low, pivot - 1);//递归左边
		qSort(L, pivot + 1, high);//递归右边
	}
}
void quickSort(SqList& L)
{
	qSort(L, 1, L.length - 1);
}
```

因为是递归，所以快排的代码其实还是还是比较简单

主要是partition函数：先选取一个关键字，使它左边的值都比它小，右边的值比它大，我们将==这样的关键字称为枢纽（pivot）==

![快排一](C:\Typora\picture\快排一.png)

![快排二](C:\Typora\picture\快排二.png)

双指针，左边发现不满足（大于的）的则交换，右边发现不满足（小于的）的则交换，最后出循环的时候一定是high = low = pivot

时间复杂度分析：快排的时间性能取决于递归的深度![快排递归树](C:\Typora\picture\快排递归树.png)

像上面这样的平衡二叉树时效率较高，最优的时候找到的枢轴总是中间值，此时深度为O(logn)，时间复杂度为O(nlogn)，最坏的情况是待排序列是正序或逆序，递归树是斜树，时间复杂度为O(n^2^)，平均是==O(nlogn)==，关键字比较交换跳跃进行，所以==快排是不稳定排序==

有问题就要优化

**快速排序的优化**：

1️⃣优化选取枢轴

pivotkey =L.[low]成为一个性能瓶颈

有人说：那么我不总是选取low对应的值，我选low和high之间的随机值——**随机选取枢轴法**，某种程度上对于基本有序的序列的性能有所提升，但也可能撞大运（找到最大最小值）☔ ☁️☔ ☁️

进一步改进：**三数取中法**：取三个关键字先进行排序，中间数作为枢轴，一般是**左端，右端，中间三个数**，从概率上来说，三个数都是大数值或小数值的概论很小

改进部分代码：

```c++
//改进部分，三数取中
int m = low + (high - low) / 2;
if (L.r[m] > L.r[high])//前两个if相当于找到最大值移到最后
{
	swap(L, m, high);
}
if (L.r[low] > L.r[high])
{
	swap(L, low, high);
}
if (L.r[m] > L.r[low])//最后一个相当于把中间值移到最前
{
	swap(L, m, low);
}
```

有时还需要九数取中，自处不再说明

2️⃣优化不必要的交换

枢轴的值最后都会回到low和high相等的位置

改进部分代码：

```c++
int partition3(SqList& L, int low, int high)
{
	int pivotkey = L.r[low];//找到枢轴值
	L.r[0] = pivotkey;//0下标位置储存枢轴关键字
	while (low < high)
	{
		while (low < high && L.r[high] >= pivotkey)
		{
			high--;
		}
		L.r[low] = L.r[high];//因为枢轴值已经被储存，我们不需要交换
		while (low < high && L.r[low] <= pivotkey)
		{
			low++;
		}
		L.r[high] = L.r[low];
	}
	L.r[low] = L.r[0];
	return low;
}
```

3️⃣优化小数组时的排序方案

大材小用反而不好用，数组非常小，快排反而不如插入排序（直接插入排序是简单排序中性能最好的）

设置一个数组长度阀值

```c++
#define MAX_LENGTH_INSERT_SORT 7
void qSort(SqList& L, int low, int high)
{
	int pivot;
	if ((high - low) > MAX_LENGTH_INSERT_SORT)
	{//大于阈值用快排 
		pivot = partition3(L, low, high);//得到分隔的下标

		qSort(L, low, pivot - 1);//递归左边
		qSort(L, pivot + 1, high);//递归右边
	}
	else//否则用插入
	{
		insertSort(L);
	}
}
```

4️⃣优化递归操作

```c++
void qSort2(SqList& L, int low, int high)
{
	int pivot;
	while(low < high)//此处改成while于low值改变搭配成尾递归
	{
		pivot = partition(L, low, high);//得到分隔的下标

		qSort2(L, low, pivot - 1);//递归左边
		low = pivot + 1;//尾递归
	}
}
```

##### 排序总结：

排序方法		平均情况		最好情况		最坏情况		辅助空间	       稳定性

冒泡排序		0(n^2^)		0(n)			0(n^2^)	        O(1)		       稳定

选择排序		0(n^2^)		0(n^2^)		0(n^2^)		O(1)		       稳定

插入排序		0(n^2^)		0(n)		        0(n^2^)		O(1)		       稳定

希尔排序		O(nlogn)		0(n^1.3^)		0(n^2^)		O(1)		       不稳定

堆排序		O(nlogn)		O(nlogn)		O(nlogn)		O(1)		       不稳定

归并排序		O(nlogn)		O(nlogn)		O(nlogn)		O(n)	        稳定

快速排序		O(nlogn)		O(nlogn)		0(n^2^)		O(logn)~O(n)不稳定



总的来说，快速排序性能最好，不是绝对的，每个排序都有用武之地，冒泡最好情况还是最快的呢，数据少的时候插入是最快的



历时一个半月，初级的数据结构的初步学习结束，但其实是远远不够的，运用不熟，一切都是空谈

以大话数据结构的结尾引用结束吧！

当别人做不到的时候，他们就想要告诉你，你也不能，你想要什么，自己争取