# 数据结构

## 第一阶段

### 1、基本概念和术语

`数据分为两类`

1、数值型的数据：整数，实数等

2、非数值型数据：文字，图像等

`数据元素（元素，记录，结点）是数据的基本单位`

数据项是组成数据元素的不可分割的最小单位

数据 > 数据元素 > 数据项

`数据对象：性质相同的数据元素的集合（如：整数集）（与数据元素区分开来）`

`数据结构三方面`

1、数据元素之间的逻辑关系——逻辑结构

—1.1线性结构——有且仅有一个开始和终端，所有结点只有最多一个前驱和后继（如：线性表，栈，队列，串）

—1.2非线性结构——结点可能有多个前驱和后继（如：树，图）

2、数据元素及其关系在内存中的表示（映像）——物理结构或存储结构

—2.1顺序存储——连续的存储单元依次存储，存储位置来表示逻辑关系

—2.2链接存储——任意存储单元，逻辑关系用指针表示

（了解即可）2.3索引存储 2.4散列存储

3、数据的运算和实现

### 2、抽象数据类型定义格式

![](C:\Typora\picture\数据结构（一）.png)

### 3、算法和算法分析

`算法定义`

解决特定问题求解步骤的描述，指令的有限序列，每个指令包括一个或多个操作

`算法的描述`

自然语言，流程图，伪代码，程序代码

`算法与程序`

算法：由输入到输出，一个问题多种算法

程序：用程序设计语言对算法的具体实现（数据结构＋算法）

`算法特性`

有穷性（有穷步，有穷时间）、确定性（指令确定，无二义性，同输入则同输出）、可行性（可以执行）、输入（>=0个）、输出（>=1个）

`算法设计要求`

正确性：

第一层（语法正确）、第二层（机组输入数据正确）、第三层（有选择、典型、刁难数据正确）、第四层（一切合法数据正确）————到达第三层算法合格

可读性：

1）易于人的理解 2）其次为计算机的执行3）易于调试

健壮性：

1）非法时做出提示反应，而不是中断

高效性：
时间少，存储低

`算法的度量方法`

事后统计：缺陷多，不予考虑

事前分析估算：

时间复杂度：先取最高阶，高阶系数1，无高阶写1（大O阶方法）

常见的有：常数阶O(1)<对数阶O(logn)<线性阶O(n)< nlogn阶O(nlogn)<平方阶O(n^2)<立法阶O(n^3)

*补充：*函数的渐进增长：两个函数f(n)，g(n)，存在N使得f(n)>g(n)恒成立，我们说f(n)的增长渐进快于g(n)

时间复杂度一般指最坏时间复杂度，平均运行时间（经过一定数量的实验估算出来）

空间复杂度：算法所需的存储空间（本课程不细讲）

## 第二阶段

### 1、线性表

`线性表定义`

零个或多个数据元素的有限序列（有头有尾，一个接一个）

#### 1、线性表的顺序存储

定义：一段地址连续的存储单元依次存储线性表的数据元素

优点：1）无需为元素之间的逻辑关系表示增加存储空间 2）存取方便 （按下标存取）

缺点：1）插入删除的时间复杂度高（可见如果要经常变动线性表不使用顺序储存）2）所需长度固定时不好开辟空间3）储存空间碎片

#### 2、线性表的链式存储

定义：n个包含数据域和一个指针域的结点链结成的链表（单链表）

头指针和头结点的区分：
头指针——第一个结点的储存位置（有头结点时指向头结点，没有则指向首元结点）

*补充*：首元结点——

![](C:\Typora\picture\数据结构（头指针）.png)

头结点——在第一个结点之前设的结点（数据域可以为空或者存储有关链表的信息,可以没有）![](C:\Typora\picture\头结点.png)

![总括图](C:\Typora\picture\链表指针.png)

链表的增删改查——最重要的是链不能断，头指针不要改变

// 补充：可以创建一个类型，至少存有头指针，还能有尾指针（便于删），目标指针（便于改查）等

增：堆区开辟结点，再接在链表末尾

删：前指后，注意释放中间结点、整条删除——两个指针p,q，q =p->next,删p，p = q

改：堆区开辟新结点，前指新，新指后

查：创建p遍历，每次p = p->next

##### 静态链表：

> 静态链表——应对有些语言没有指针，**用数组描述的链表叫静态链表**
>
> 数据域——data和cur（下一元素的下标）
>
> 数组首元素cur为备用链表的第一个，也就是加入新数据的时候将要占的位置
>
> 数组末元素cur为链表的第一个数据，也就是遍历的时候显示的第一个
>

静态链表的增删改查——类中实现(按住ctrl再点击链接才能跳转

[静态链表.cpp · 莫威/大一c语言 - 码云 - 开源中国 (gitee.com)](https://gitee.com/mo-w/freshman-c-language/blob/master/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.cpp)

增

```c++
void addList()
	{
		int n = 0;
		cout << "请输入要添加的个数" << endl;
		cin >> n;
		int j;
		int k;
		cout << "输入添加的数" << endl;
		for (int i = 0; i < n; i++)
		{
			cin >> j;
			k = m_list[0].cur;//将使用的结点 
			m_list[k].data = j;//新元素插入进备用链表的第一个,即数组第一个元素的cur
			m_list[0].cur = m_list[k].cur;//找到下一个备用链表的第一个
			if (m_list[MAXSIZE - 1].cur == 0)
			{
				m_list[MAXSIZE - 1].cur = k;
			}
		}
		m_list[k].cur = 0;//表示后面没有元素
		return;
	}
```

删：

```c++
void deleteList()
	{
		cout << "输入你要删除的位置" << endl;
		int i = 0;
		cin >> i;
		int k = m_list[MAXSIZE - 1].cur;
		for (int j = 0; j < i - 2; j++)//找到i之前的元素 
		{
			k = m_list[k].cur;
		}
		if (i == 1)//删第一个是特例
		{
			m_list[MAXSIZE - 1].cur = m_list[k].cur;
		}
		else
		{
			m_list[k].cur = m_list[m_list[k].cur].cur;
		}
		m_list[i].cur = m_list[0].cur;
		m_list[0].cur = i;
	}
```

改：

```c++
//链表的插入
	void insertList()
	{
		cout << "输入你要插入的位置" << endl;
		int i = 0;
		cin >> i;
		cout << "输入你要插入的元素" << endl;
		int e;
		cin >> e;
		int m = m_list[0].cur;
		m_list[m].data = e;//将元素存在备用链表第一个元素 
		m_list[0].cur = m_list[m].cur;//新的备用链表第一个元素
		int k = m_list[MAXSIZE - 1].cur;
		for (int j = 0 ;j < i-2;j++)//找到i之前的元素 
		{
			k = m_list[k].cur;
		}
		if (i == 1)//第一个特例 
		{
			m_list[m].cur = m_list[MAXSIZE - 1].cur;
			m_list[MAXSIZE - 1].cur = m;
		}
		else
		{
			m_list[m].cur = m_list[k].cur;
			m_list[k].cur = m;
		}
	}
```

查：

```c++
void showList()
	{
		for (int k = m_list[MAXSIZE - 1].cur; k!=0; k = m_list[k].cur)
		{
			cout << m_list[k].data;
		}
	}
```

##### 循环链表：

定义：单链表中终端结点的指针指向头结点，从而形成环

与单链表区别：可以循环访问结点

结束条件：p->next等于头结点

循环链表一般会建立一个尾指针（指向最后一个结点）, 从而使查找最后一个元素(rear)，和首元素（rear->next->next）变得容易，时间复杂度为O(1)

也方便两个循环链表的合并:

```c++
p = rearA->next;//保存链表A的头结点
rearA->next = rear->next->next;//A的尾结点的指针指向B链的首元结点（不是头结点）
rearB->next = p;//B链的尾结点指向A的头结点（也是合并后的一条链的头结点）
p = NULL;//p置为空
```

##### 双向链表：

与单链表的区别：每个结点设置一个指向其前驱的指针域(*prior)

> 也可以有循环双向链表（可以理解为头既是尾，尾既是头，见下图）

![](C:\Typora\picture\双向链表.png)

> 俗话说：努力才有回报，既然多了指针，那么在对结点进行操作的时候也会多一点步骤，其实也就是以单链表为基础，加入一点逆向思维😀 ，如：

插入：

后驱指针：

```c++
s->next = p->next;
p->next = s;
```

前驱指针（将尾看成头，所以与后驱相反）：

```c++
s->prior = p;
p->next->prior = s
```

删除(简单易懂，清晰明了)：

```c++
 p->prior->next = p->next;
 p->next->prior = p->prior;
 delete p;
```

### 2、栈与队列

#### 1、栈

定义：限定仅在表尾进行插入和删除的线性表（后进先出的特殊线性表）

> 组成部分

栈顶：允许插入删除的一端（表尾指的是栈顶）

栈底：与栈顶相对的另一端

空栈：不含任何元素的栈

> 栈的操作

栈的插入（进栈，压栈，入栈）：push

栈的删除（出栈）：栈顶元素出栈：pop

需要弄清元素的出栈顺序种数：eg ：3个元素（1，2，3）有五种出栈的顺序

> （1入1出，2入2出，3入3出）123
>
> （1，2入，2，1出，3入3出）213
>
> （1，2，3入，3，2，1出）321
>
> （1入1出，2，3入，3，2出）132
>
> （1，2入，2出，3入，3，1出）231

##### 栈的顺序储存结构及实现：

顺序栈：以下标0为栈底，定义top表示栈顶元素在数组中的位置，可以移动，但要小于stackSize，top = 0时有一个元素，top = -1时为空栈

进栈：

```c++
//模拟入栈函数
void push(MyStack* s, int a)//自己创建的栈类型，a为要push的数
{
	if (s->top == MAXSIZE - 1)//当top达到栈的最大长度
	{
		cout << "栈已满" << endl;
		return;
	}
	s->top++;//栈顶指针加1
	s->data[s->top] = e;//元素赋给栈顶元素
	return;
}
```

出栈；

```c++
//模拟出栈函数
void pop(MyStack* s, int *a)//自己创建的栈类型，a为要push的数
{
	if (s->top == - 1)//空栈
	{
		cout << "栈已满" << endl;
		return;
	}
	*a = s->data[s->top];//将将要删除的栈顶元素赋给a
	s->top--;//栈顶指针减1
	return;
}

```



#####  两栈共享空间——一个数组两个栈

使用场景：通常两个栈的空间需求有相反关系时，即一个增另一个就要减的情况

![](C:\Typora\picture\两栈共享空间.png)

栈1：空栈：top1 = -1，满栈top1 = n-1；

栈2：空栈：top2 = n，满栈top2 = 0；

但一般情况下两栈的top会在中间相遇，不过，不论在哪个位置相遇，都会有top1 +1 = top2 （栈满判断）

类型创建（两个top）

![](C:\Typora\picture\共享栈类创建.png)

入栈、出栈与普通栈的区别：多传一个参数，判断是要对哪一个栈进行操作

##### 栈的链式储存结构及实现：

简称为：**链栈**、

因为我们一般知道链表的头指针，而栈顶指针也是必须的，为了方便，我们合二为一😍（也就是把头部看成栈顶），相信此时你已经看出来了，栈顶是要有元素的，所以链栈是不需要头结点的。

栈满：你确定？链栈会满吗✋

空栈：top = NULL；

链栈的操作：

绝大部分操作都与单链表一致，在插入删除有些许区别

进栈操作：

```c++
//模拟出栈函数
void push(LinkStack* s, int a)
{
	LinkStack t = new LinkStack;//创建新结点
	t->data = a;//添加新结点数据域
	t->next = s->top;//新结点指向原栈顶
	s->top = t;//新结点设为新栈顶
	s->count++;//链栈的长度加1
	return;
}
```

出栈操作：

```c++
//模拟出栈函数
void pop(LinkStack* s, int* a)
{
	LinkStack p;
	if (StackEmpty(*s))
	{
		return;
	}
	*e = s->top->data;//删除元素的返回
	p->top;//p先暂时存储，以便释放
	s->top = s->top->next;//栈顶后移 
	delete p;//释放原栈顶
	s->count--;//栈中元素个数减1
	return;
}
```

经典环节：顺序栈和链栈的优缺点（便于分析什么时候使用）

元素个数变化无法估量（或大或小）—— 链栈

个税可控范围内——顺序栈（毕竟不需要指针域的内存开销，和链表结点的创建）

——————————————————————————————————————————————————

##### 栈的作用：

已经开始笑了😃 ，问题千千万，每一个问题都有最适合的那个解答，其实就是最适合的数据结构， 每一种前人发明的数据结构终将会有他的用武之地。

##### 栈的应用：

###### 1、递归（重要⭐）

定义：一个直接调用自己或通过一系列调用语句间接地调用自己的函数，称作递归函数

举个例子吧——斐波那契数列实现

1，1，2，3，5，8，13，21……

![](C:\Typora\picture\斐波那契数列.png)

```c++
//斐波那契数列
int Fbi(int i)//i为要求的结果对应的元素
{
	if (i < 2)//出口
	{
		return i == 0 ? 0 : 1;//看成从0开始确实是一个好办法啊，想不到就要记住
	}
	return Fbi(i - 1) + Fbi(i - 2);//不断调用自己，但i不断考靠近出口
}
```

主要：有元素和之前的元素之间（一个或多个）总是有相同的关系，有出口，并且在不断递归的情况下会逐渐靠近出口

迭代与递归：

其实上述实例用迭代（使用循环结构）也可以做，递归与之相比——结构更简洁，便于理解（好处），建立大量函数副本（耗时耗内存），自己取舍然后选用就行了❤️ 

###### 2、四则运算表达式求值（图多——因为自己表达不出来）

情境就是四则运算不能完全按从左到右地算数顺序，得先乘除后加减，有括号还得算括号里面的，这不就是有栈的感觉吗☀️ ——牵强吧，我也觉得，好了，往下看，波兰大逻辑学家（名字太长，导致人们不想记，就用他的国籍来记录了，为何不叫trump）的杰作
后缀（逆波兰）表示法定义：不需要括号的后缀表示法

“**9** + **(3-1)×3** + **10÷2**” （中缀表达式）  ------->"9 3 1- 3* + 10 2 / +" ❗❓

![](C:\Typora\picture\中缀转后缀.png)

这些流程其实计算机会帮我们做好，你看着也不爽是吧，因为这本来就是给计算机看的

表示好之后当然就是开始用了，主角登场——栈

![](C:\Typora\picture\四则运算.png)

#### 2、队列

定义：只允许一端进行插入操作，另一端进行删除操作的线性表

先进先出（可以与栈做一个对比）

插入端：队尾

```c++
//入队函数模拟
void enQueue(SqQueue* Q, int a)//设数据域为一个整型
{
	if ((Q->rear + 1) % MAXSIZE == Q->front)//好方法需记住，循环用模
	{
		cout << "队列已满" << endl;
	}
	Q->data[Q->rear] = a;//元素入队
	Q->rear = (Q->rear + 1) % MAXSIZE;//又是一个小技巧，解决了当rear后移超出时设为0的烦恼
}
```

删除端：队头

```c++
 //模拟出队函数
void deQueue(SqQueue* Q, int* a)
{
	if (Q->rear == Q->front)
	{
		cout << "队列为空" << endl;
	}
	*e = Q->data[Q->front];//出队元素赋值给a
	Q - 》font = (Q->front + 1) % MASSIZE;//出现多少次，不用多说了
}
```

顺序储存（不足之处较多，不过多赘述）：容易越界，内存浪费

##### 循环队列：

定义：头尾相接的顺序储存结构的队列（当rear到最后一个时改为0）

空队列时：rear == front

队列满时——判断方法：
方法一：front == rear（与空队列的条件一致，所以要设标志变量flag）flag ==1时队列满

方法二：队列留一个元素（不完全存满）——rear和front差1

![](C:\Typora\picture\循环队列.png)

*补充*：queueSize为队列的最大长度（上图为5，但其实用方法二只能存4个）

rear在front左或右，但统一过来都会有**（rear +  1）% queueSize = front**（循环用模需记住☝️）

队列长度：统一公式**（rear - front +queueSize）%queueSize**

> rear >front ——rear - front
>
> rear < front——queueSize -font + rear

##### 队列的链式存储结构及实现：

**把握几点：一般有头结点，front的后继是队头元素，rear的后继是队尾元素**

就算已经想出来了循环队列，但还是不能解决无法预估长度的情况，此时需要链队列

定义：其实就是单链表只能从尾进从头出罢了

空队列：front，rear指针都指向头结点

入队：

```c++
//入队模拟函数
void enQueue(LinkQueue* Q, int a)
{
	QueueNode* s = new QueueNode;
	if (!s)//储存分配失败
	{
		cout << "开辟空间失败" << endl;
		exit(OVERFLOW);
	}
	s->data = a;
	s->next = NULL;
	Q->rear->next = s;//与顺序储存稍稍有区别，这里是rear的后继指向新入队元素
	Q->rear = s;//新队尾设置
}
```

出队：

```c++
//入队模拟函数
void enQueue(LinkQueue* Q, int* a)
{
	QueueNode p;//创建临时结点
	if (Q->rear == Q->front)
	{
		cout << "队列为空" << endl;
	}
	p = Q->front->next;//将预删除的对头暂存于p
	*a = p->data;
	Q->front->next = p->next;//头结点后移
	if(Q->rear == p)//注意：如果队列此时为空，需要把队尾指针指向头结点
	{
		Q->rear = Q->front;
	}
	delete p;//释放p
}
```

### 3、 串

定义：零个或多个字符组成的有限序列，又名字符串

空串：零个字符的串——“”或空集字符表示

空格串：只包含空格的串——不是空串（可以有多个空格）

子串和主串：子串在主串的位置是子串的第一个字符在主串中的序号

——————————————————————————————————————————————————

串的比较（不是长度比较）：

常用字符使用ASCII编码（8位二进制数）——可以表示256个，显然不够

出现Unicode编码（16位二进制数）——前256个字符与ASCII码完全相同

两字符串从左到右逐个字符依次比较，遇到不同字符时比较编码的大小

eg.   s = "happen" t ="happy"  e(ASCII) < y(ASCII)-------->  s < t

##### 串的储存结构：

顺序储存——以 '\0'结束

链式储存——就是链表，可以一个结点存1个字符，但内存可能浪费较大，可以存多个，没存的地方用#等其他字符补上（如一个结点存五个字符，我只存了三个，剩下两个补#，#），具体存几个看你需要的功能

##### 朴素的模式匹配算法：

**子串的定位操作通常称为串的模式匹配**

```c++
//返回主串中pos位置之后的子串的位置，假设r[0],s[0]存字符串长度,但需要注意减'0'
int index(string& r, string& s, int pos)
{
	int i = pos;//主串从pos开始
	int j = 1;//子串从1开始
	while (i <= r[0] - '0' && j <= s[0] - '0')//减'0'是为了将字符类型转为整型大小
	{
		if (r[i] == s[j])//相等后移
		{
			j++;
			i++;
		}
		else//如果出现不相等，主串后移一位，子串回归1
		{
			i = i - j + 2;
			j = 1;
		}
	}
	if (j > s[0] - '0')
	{
		return i - s[0] +  '0';
	}
	else
	{
		return 0;
	}
}
```

三种情况时间复杂度分析：

一开始就找到：O(1)

找到之前都是首字母就不匹配:O（n + m）n（主串长度），m（子串长度）

找到之前每次都是最最后一个字母不同：O((n-m-1)*m)

不是危言耸听，最后一种情况是会经常出现的，这样看来，这个算法太低效了✋✋

##### KMP模式匹配算法✨：

又到了激动人心的学习大佬的算法的时候：克努特—莫里斯—普拉特算法（这次名字写全来表现respect）——简写为KMP算法，大大避免重复遍历的情况

*补充：i为查找时指向主串中字符的遍历下标，j为查找时指向子串中字符的遍历下标*

原理：朴素为什么不行？就是因为主串的查找i还在不断的做无意义的回溯，KMP最重要的是把子串看成模板，只让子串做回溯。

如何让子串做回溯？

**精髓是——next数组**

也就是说子串的每一个字符下都会对应一个next元素，来指引j如何变动

![](C:\Typora\picture\KMP手稿.jpg)

精髓就是找next数组：

```c++
//得到next数组的函数，子串是模板串，每个模板串会有一个next数组
void getNext(string& r, int* next)//r为模板串，next为需要求的数组
{
	int j = 0;//j从0开始，也表示前后缀没有一个匹配上的
	int i = 1;//数组从1开始存——更加大众，更加方便
	next[1] = 0;//啊喂，第一个就没有配对成功，当然用0来记录这个特殊情况了——那就是i要向后移1位了

	while (i < r[0] - '0')//假设r[0]存的是字符串长度，位置1已存，所以还剩长度减1个要存
	{
		if (j == 0 || r[i] == r[j])//j为0可以进入，此时i记为1（其实还是有可能存0，升级版会解决）
		{
			j++;
			i++;
			next[i] = j;
		}
		else//当前后缀相等的个数增中断时，j需要回溯
		{
			j = next[j];//现在还不清楚为什么这一句可以回溯，以后需要解决
		}
	}
	return;
}
```

匹配代码：注意——* *之间的代表与朴素不同之处

```c++
int index(string& s, string& t, int pos)
{
	int i = pos;//主串起始
	int j = 1;//子串起始

	int next[255];
	getNext(t, next);//得到next，如果用getNextval记得更改
	while (i <= s[0] - '0' && j <= t[0] - '0')
	{
		if (*j == 0* || s[i] == t[j])//不同之处意义——next数组中0所代表的特殊情况i也需要后移1位
		{
			i++;
			j++;
		}
		else
		{
			*j = next[j]*;//不同之处意义——KMP算法，只需要j来进行有意义的移动
		}
	}
	if (j > t[0] - '0')
	{
		return i - t[0] + '0';
	}
	else
	{
		return 0;
	}
}
```

你敢相信，这已经是十分高效的方法了，居然还可以继续升级：

KMP算法的升级：

肯定是升级next数组，变为了nextval数组，这是怎么回事？这就是回到上面说的，其实有些对应的下标并不是最终要达到的位置，比如下面这个例子：

![](C:\Typora\picture\next-nextval.png)

假如用next，在'b'处匹配失败，会让8号位的'a'来比较，假如又失败，7号位'a'来判断（j跳转后所指元素和跳转前所指元素相同，这不是必不匹配吗），之后还有6号位，5号位……，实在是浪费时间，我们为什么不在设置next数组的时候就解决好**出现跳转前后相等的情况**，也就是相等就改变next数组的元素为跳转后next数组中的元素，直至不再相等

```c++
void getNextval(string& r, int* next)//r为模板串，next为需要求的数组
{
	int j = 0;//j从0开始，也表示前后缀没有一个匹配上的
	int i = 1;//数组从1开始存——更加大众，更加方便
	next[1] = 0;//啊喂，第一个就没有配对成功，当然用0来记录这个特殊情况了——那就是i要向后移1位了

	while (i < r[0] - '0')//假设r[0]存的是字符串长度，位置1已存，所以还剩长度减1个要存
	{
		if (j == 0 || r[i] == r[j])//j为0可以进入
		{
			j++;
			i++;
			next[i] = j;
			while (r[next[i]] == r[i])//与next添加了这个循环，用于循环判断当前i的元素与回退后的元素是否相等，相等执行下面步骤
			{
				next[i] = next[j];
			}
		}
		else//当前后缀相等的个数增中断时，j需要回溯
		{
			j = next[j];//现在还不清楚为什么这一句可以回溯，以后需要解决
		}
	}
	return;
}
```

## 第三阶段

### 1、树

定义：n（n>=0）个结点的有限集.n=0时为空树.任意非空树中:(1)**有且仅有一个特定的称为根的结点**(2)n>1时,其余结点可分为m(>0)个互不相交的有限集,每个集合又是一棵树,称为根的子树

子树:是相对于结点来说的(结点的度个数和该结点的子树个数相同)

度:结点拥有子树数

树的度:各节点度的最大值

不同子树的个数没有限制,但一定是互不交互的

结点分类:

> 叶结点(终端结点):度为0
>
> 非终端结点(分支结点):度不为0
>
> 内部结点:除根节点之外

结点间关系（其实是很生动形象了㊙️）

结点的孩子：结点子树的根

结点的双亲：与孩子的概念相对，你叫我孩子，我肯定叫你双亲啊

结点的兄弟：同一双亲的孩子之间互叫兄弟

结点的祖先：从这个树的根到该结点所经分支上的所有结点（包括双亲）

![](C:\Typora\picture\结点间的关系.png)

结点的层次：上图有四层，根为第一层，以此类推

结点的深度（高度）：上图深度为4，结点的最大层次

有序树：将子树从左至右看成有次序的

无序树：将子树从左至右看成无次序的

森林：m（m>=0）棵互不相关的树的集合

#### 树的存储结构：

##### 双亲表示法：

*补充*：其中说的所有域，如果不存在就设为1

**每个结点设一个指示器指向结点的双亲在表中的位置**——缺陷：不能轻松找到结点的孩子

改进：增加最左边孩子的域（长子域）

但如果不止长子怎么办，增加了右兄弟域

可以看出来，存储结构是十分灵活的，存储结构是否合理，取决于我们要解决的问题和时间复杂度（意思是设置的域不是越多越好，注意考虑）

##### 孩子表示法：

每个结点有多个指针域，每个指针指向一棵子树的根结点——多重链表表示法

因为每个结点的度是不同的，我们提供以下两种方案：
方案一——指针域的个数等于树的度

这种方法确保了所有结点的指针域都够用，但不同结点的度相差较大时比较浪费空间

方案二——按需分配，指针域的个数等于结点的度

我们会专门取一个位置来存结点的度——degree（度域）

空间的浪费确实减少了，但运算上时间的损耗会增加

——————————————————————————————————————————————————人总是贪心的 ✴️，贪心导致人类社会的进步，导致发现了更好的方法——孩子表示法（这里才进入正题❗❓❕❔）

实现方法：

每个结点的孩子结点排列起来，以单链表作储存结构，n个结点就有n个孩子链表（叶子结点此单链表为空），n条单链表总有n个头指针（不是头结点，一般孩子链表不加头结点）吧，再粑n个头指针组成一个线性表（顺序结构储存），存进一维数组中

```c++
//孩子结点
typedef struct CTNode
{
	int child;
	struct CTNode* next;
}*ChildPtr;

//表头结构
typedef struct
{
	//TElemType data;//此处可以加相关数据
	ChildPtr firstchild;//孩子链表的头指针
}CTBox;

//树结构
typedef struct
{
	CTBox nodes[MAXSIZE];//结点数组
	int r, n;//根节点位置和结点数
}CTee;
```

孩子表示法找不到双亲，可以升级成双亲孩子表示法（其实就是多加一个指向双亲的域而已），不过多赘述了

##### 孩子兄弟表示法：

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。因此就回到我们在双亲表示法中提到的，两个指针，分别指向该结点的第一个孩子和此结点的右兄弟

```c++
typedef struct CSNode
{
	//TelemType data; 数据域
	struct CSNode* firstchild, * rightsib;
};
```

如果你又想找妈妈（开玩笑）——找双亲，大声说出那几个字——设指向双亲的域

其实这个表示法的最大好处是把树变成了二叉树（❓❓❓❓❓❓❓❓❓❓）——这就是接下来的重点⭐

#### 二叉树✨：

##### 二叉树定义：

定义：n(n>=0)个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点的两棵互不相交的、分别称为根结点的**左子树和右子树**的二叉树

特点：

结点最多两棵子树（度为0，1，2）

左右子树是有顺序的（就算只有一个子树，这个子树**也要分清是左子树还是右子树**）——下图两个树就算不同的

![](C:\Typora\picture\二叉树（一）.png)

这就引出了二叉树的五种形态：1、空二叉树 2、只有一个根结点 3、根结点只有左子树 4、根节点只有右子树 5、根结点既有左子树又有右子树

特殊二叉树——肯定是斜的了，所有结点只有左子树的叫左斜树，只有右子树的叫右斜树，统称斜树

⚡ ⚡ 不就是线性表吗⚡ ⚡ ，对，其实线性表可以看成是树的一种特殊表现形式

满二叉树——**所有结点都有左子树和右子树**（除了叶子结点），**叶子也需要都在同一层上**

完全二叉树——与满二叉树相比记忆，就是说完全中有的结点满中都有（满要求比完全更严苛）

完全二叉树：![](C:\Typora\picture\二叉树（三）.png)

不是完全二叉树：![](C:\Typora\picture\二叉树（二）.png)

简单来说：从第二层开始，左右左右的排（不存在只有右子树没左子树的情况），没排满就不能排下一层（只能最下面一层没有排满）

##### 二叉树性质：

性质1：第i层至多 2^i-1^ 个结点

性质2：深度为k，至多2^k^-1个结点（k>=1）

性质3：终端结点数等于度为2的结点数+1

推导：n为总结点数，n~0~为度为0的结点（叶子），n~1~为度为1的结点，n~2~为度为2的结点

连接线的数为n-1，有n-1 = n~1~ + 2n~2~ 和n = n~0~ + n~1~ + n~2~，两式子一化简得n~0~ = n~2~ + 1 

性质4：n个结点的二叉树的深度为[log~2~n] + 1（[x]表示不大于x的最大整数）

性质5：前提是n个结点的完全二叉树，按层编号i（ 1<=i<=n）

> i=1是二叉树的根，无双亲，i>1，双亲结点是[i/2]
>
> 2i>n，则结点i无孩子（叶子结点），否则左孩子是2i（上一点的逆用）
>
> 2i  + 1> n, 结点无右孩子，反之2i+1是右孩子

##### 二叉树的存储结构：

顺序存储：一般的树用顺序结构实现比较困难，而二叉树比较特殊

一般二叉树：按照完全二叉树的标号来存储，不存在设置为^（但如果出现极端情况——右斜树，这就很难受啊）        

所以，**顺序结构一般只用于完全二叉树**

二叉链表：

每个结 点最多两个孩子，（所以结点中设计一个数据域和两个指针域）——这就叫二叉链表

经典环节：想找双亲，如有需要增加指向双亲的指针域——这就变为了三叉链表

##### 遍历二叉树：

原理：从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问且只访问一次

遍历方法：遍历方法很多，假如限制了从左至右的习惯，主要有以下四种

**其实主要就是递归的使用：**

**1、前序遍历**

若二叉树为空，则空操作返回，若非空，先访问根节点，然后前序遍历左子树，再前序遍历右子树

图示：![](C:\Typora\picture\前序遍历.png)

代码实现：

```c++
void preOrder(TreeNode *node)//递归遍历
{
	if (node == NULL)
	{
		return;
	}
	cout << node->data << endl;//访问本结点
	preOrder(node->lchild);//先左子树
	preOrder(node->rchild);//后右子树
} 
```

**2、中序遍历**

若二叉树为空，则空操作返回，若非空，从根节点开始（注意不是先访问根结点），先中序遍历根结点的左子树，然后访问根节点，最后右子树

图示：![](C:\Typora\picture\中序遍历.png)

代码实现：

```c++
void middleOrder(TreeNode *node)//递归遍历
{
	if (node == NULL)
	{
		return;
	}
	middleOrder(node->lchild);//先左子树
	cout << node->data << endl;//访问本结点
	middleOrder(node->rchild);//后右子树
} 
```

**3、后序遍历**

若二叉树为空，则空操作返回，若非空，从左到右先叶子后结点的方式遍历访问左右子树，最后根结点

图示：![](C:\Typora\picture\后序遍历.png)

代码实现：

```c++
void postOrder(TreeNode *node)//递归遍历
{
	if (node == NULL)
	{
		return;
	}
	preOrder(node->lchild);//先左子树
	preOrder(node->rchild);//后右子树
	cout << node->data << endl;//访问本结点
} 
```

**层序遍历：**

若二叉树为空，则空操作返回，若非空，从根结点开始访问，从上往下遍历，同层是从左往右逐个访问

图示：![层序遍历](C:\Typora\picture\层序遍历.png)

代码实现：

```c++
//队列实现树的层序遍历
void floorOrder(TreeNode* node)
{
	queue<TreeNode> q;//创建队列
	if (NULL != node)
	{
		q.push(*node);
	}
	while (q.empty() == false)//队列不为空
	{
		cout << q.front().data << "->" << endl;
		if (NULL != q.front().lchild)
		{
			q.push(*q.front().lchild);
		}
		if (NULL != q.front().rchild)
		{
			q.push(*q.front().rchild);
		}
		q.pop();
	}
}
//数组实现树的层序遍历——只是用数组模拟队列了（小亮整个活——忽略）
void floorOrder(TreeNode* node)
{
	TreeNode* temp[100] = { NULL };//数组初始化
	int rear = 0;//相当于记录队尾
	int front = 0;//相当于记录队头

	if (NULL != node)
	{
		temp[rear++] = node;//保留根结点
	}
	while ((rear+1)%100 != front)
	{
		if (temp[front] != NULL)
		{
			cout << temp[front]->data << "->";
			temp[(rear++) % 100] = temp[front]->lchild;//模100是循环队列的意思
			temp[(rear++) % 100] = temp[front]->rchild;
		}
		temp[front] == NULL;
		front = (front++) % 100;
	}
}
```

注意一种题型：推导遍历结果

例：中序：CBAEDF 前序：ABCDEF  推后序遍历结果为CBEFDA

​       中序：ABCDEFG 后序：BDCAFGE 推前序遍历结果为EACBDGF

**必须是中序（必有）和（前序、后序）——  二选一 能推出剩下的一个

说实话，刚刚推一个就花了我十多分钟来推，果然没有方法是不行啊，接下来是刚才十分钟所悟到的：
1、必须两个结合来看，一条路走不通赶紧换另一个，我刚才好像就是中前中前交替才能推出的

2、牢记实现本质：前——自左右，中——左自右，后——左右自

3、不同序能推出什么特定的东西：

（1）前序：第一个肯定是树的根，第二个一定是孩子（靠中序分左右孩子），子树又是树，孩子是啥（🤝子树的根啊🤝），然后呢，再把子树的根看成主要的（再次依靠中序分左右子树的结点）**——找根，根紧挨的下一个一定是孩子（左右考中序）**

**（2）✨中序✨：分出左右子树的结点，根左边的结点一定是左子树的结点，右边反之。**

（3）后序：最后一个肯定是根，倒数第二个肯定是孩子（靠中序分左右）——后面与前序的作用基本一致，不就是逆向思维，从后面开始找根吗，你是个聪明的孩子，逆向思维不是简简单单

这可是我今晚的心血啊，防止以后失智，还是写下两个例题吧：

![](C:\Typora\picture\推导遍历结果.jpg)

##### 二叉树的建立：

要点，上面的遍历其实是二叉树所有操作的一种，是通过递归得到，其实对本结点所做的操作就是那个打印数据，其实可以继续拓展，所有操作其实只需要把打印操作换成相应操作就行了（那么也会有前中后三种方法），理解遍历基本所有的操作都可以做了

**扩展二叉树**：为了让每个结点都有左右孩子（也就是每个结点都在对应位置），如果某个位置没有结点就引出一个虚结点，例如用“#”来表示，如下图就可以输入AB#D##C##

![](C:\Typora\picture\扩展二叉树.png)

```c++
//前序插入结点，自处结点的数据域为字符
void creatBiTree(BiTree* t)//此处传入的是二级指针，BiTree是指向BiTNode的指针
{
	char ch;
	cin >> ch;
	if (ch == '#')
	{
		*t = NULL;
	}
	else
	{
		*t = new BiTnode;//因为不是指定值#，开辟新结点
		if (*t == NULL)
		{
			exit(OVERFLOW);
		}
		(*t)->data = ch;//生成根结点
		creatBiTree(&(*t)->lchild);//递归构造左子树
		creatBiTree(&(*t)->rchild);//递归构造右子树   
	}
}
```

**线索二叉树：**

原理：为了节约空间，其实每个普通二叉树会有很多空指针，这些完全就是浪费空间，不如利用起来。

空指针个数：n+1

n个结点，2n个指针域，n-1个分支线（也就是已经使用过的指针域），空指针域2n -（n - 1） = n+ 1

引出话题：假设我们中序遍历的时候得到HDIBJEAFCG这样的遍历顺序，我们就已经知道不同元素的遍历顺序是怎样的（就像线性表一样），假如我们能让每个元素都找得到前趋后继，以后对数据操作起来会更加方便，这时边要加入一些线索，加上线索的二叉链表称为线索链表，二叉树便称为线索二叉树。

![](C:\Typora\picture\线索二叉树（一）.png)

![](C:\Typora\picture\线索二叉树（二）.png)

最终效果：![](C:\Typora\picture\线索二叉树最终效果.png)

线索化：有一部分的前驱后继是由原本的左右孩子指针的，一部分是由线索（也就是原来的空指针实现的）——**左孩子空指向前驱，右孩子空指向后继**，最终变成了类似于双向链表的结构。

我一直相信的就是中庸之道，万事万物有好处，必须有坏处来中和。

是的，现在左右指针都已经有了指向，但是我怎么知道它是真的指向孩子，还是逻辑上的前驱后继呢，我们又需要设计两个标志域，ltag，rtag（只存0，1，用bool来减少占用的内存空间），当标志域为0时指的是孩子，1时为前驱后继

代码实现：

补充的点：

一：以下是中序遍历(目前来看中序最强悍，毕竟原本的左右孩子指向就有前后继的意思)的线索化（前序后序也行，把左右子树的递归更改以下位置就行了）

二：仔细看下面的代码，**再本身要进行的操作主体（这里是把打印换为了线索化）**——再次说明我们只要在递归之外写主体就行

```c++
BiTree pre;//始终指向上一个结点
void creatClueTree(BiTree& p)
{
	if (p == NULL)//如果结点为空，直接返回
	{
		return;
	}
	if (p->ltag == 0)//建立线索后，这个判断重要，可以保证递归进入孩子，而不是建立的线索联系
	{
		creatClueTree(p->lchild);//左子树建立
	}
	//线索的构建
	if (!p->lchild)
	{
		p->ltag = 1;
		p->lchild = pre;
	}
		if (pre != NULL && pre->rchild == NULL)//如果此时右孩子的指针域还为空
		{
			pre->rtag = 1;
			pre->rchild = p;
		}
	pre = p;//更改上结点所指
	if (p->rtag == 0)
	{
		creatClueTree(p->rchild);//右子树建立
	}
}
```
好了，我们已经线索化完成了，这时我们想到使用一个**头结点**来管理这个线索链表，可以进行从最后一个元素往前遍历，也可以从第一个往后遍历：

![](C:\Typora\picture\含头结点的线索二叉树.png)

遍历的精髓就是找到首个被遍历的元素或者最后一个被遍历的（不要转牛角尖，灵活变通），举例

从前往后：

```c++
void printTipsTree(BiTree& T) {   //遍历线索化之后的二叉树 
	if (T == NULL)//树如果为空
	{
		return;
	}
	while (T->ltag == 0)//这次循环就是为了找首元素，
    {    
		T = T->lchild;
	}  
	while (T) //从前往后，直到最后一个
	{    
		cout << T->data << endl;   //输出当前节点 
		T = T->rchild;  //最后一个节点的右指针为空  结束整个循环 
	}
}
```

从后往前：

```c++
void printTipsTree(BiTree& T) {   //遍历线索化之后的二叉树 
	if (T == NULL)//树如果为空
	{
		return;
	}
	T = pre;//尾元素找到
	while (T) //从后往前，直到第一个
	{    
		cout << T->data << endl;   //输出当前节点 
		T = T->lchild;  //到达第一个结点的左指针域会为空，结束循环 
	}
}
```

有头结点的线索化代码如下：

```c++
void addHeadNode(BiTree& t)
{
	head->ltag = 0;//头结点指针必有指向
	head->rtag = 1;
	head->rchild = head;//初始化指向自身
	if (t == NULL)//树如果为空
	{
		head->lchild = head;//树为空，左指针域指向自身
	}
	else
	{
		head->lchild = t;//左指针指向根
		pre = head;
		creatClueTree(t);//此时进行线索化
		pre->rchild = head;//线索化结束，pre指向最后访问的结点
		pre->rtag = 1;
		head->rchild = pre;//右指针指向最后一个元素
	}
}
```

加头指针是为了更好的找头和尾，最终也是为了分别从前后遍历，循环判断时条件改为T != head 即可。

#### 树、森林、二叉树的转换

**树转换为二叉树：**

方法：1、兄弟互相加线2、双亲减线，只留双亲与左孩子3、图形调整

宗旨，左孩子还是双亲的左孩子，但右兄弟会变成右孩子（兄弟不就是孩子吗🥰🥰🥰）![](C:\Typora\picture\树-二叉树.png)

**森林转二叉树：**

方法：森林中的每一棵树先转为二叉树，然后不同树的根以兄弟关系自居，也就是右孩子![](C:\Typora\picture\森林-二叉树.png)

**二叉树转树：**

显然就是一个逆过程

方法：二叉树的右孩子是树中的右兄弟![](C:\Typora\picture\二叉树-树.png)

**二叉树转森林：**

逆过程，方法：根节点有右孩子就是森林

先将森林断成树再将每一棵二叉树转树即可![](C:\Typora\picture\二叉树-森林.png)

树与森林的遍历：
树：

1、先根遍历树：先访问根节点，再依次遍历根的每棵子树，举例（二叉树转树中的步骤三中的图）ABEFCDG

2、后根遍历：先后根遍历每棵子树，再访问根节点，举例（二叉树转树中的步骤三中的图）EFBCGDA

森林：

1、前序遍历：用先根遍历访问第一棵树，然后依次访问剩余的树

（二叉树转森林步骤二的图）ABCDEFGHJI（与对应二叉树的前序遍历相同）

2、后序遍历：用后根遍历访问第一棵树，然后依次访问剩余的树

（二叉树转森林步骤二的图）BCDAFEJHIG（与对应二叉树的中序遍历相同）

由此可见：森林的遍历也转到二叉树的遍历上去了😀 😃 🥰 😍 😘

#### 赫夫曼树及其应用：

最基本的压缩编码方法——赫夫曼编码

赫夫曼在编码中用到的特殊二叉树——赫夫曼树

##### 赫夫曼树的定义与原理：

> 路径长度：从树中一个结点到另一个结点之间分支构成的两个结点之间的路径上的分支数目（就是线段根数）
>
> 树的路径长度：根到每一个结点的路径长度之和

结点的带权路径长度：该结点到根结点的路径长度 × 结点的权值

树的带权路径长度——树的所有叶子结点的带权路径长度之和

**`赫夫曼树（最优二叉树）—— 带权路径WPL最小的二叉树`**

![](C:\Typora\picture\赫夫曼树.png)

上图中WPL = 5 × 3 + 15 × 3 + 40 × 2 + 30 × 2 + 10 × 2 = 220

这样可以使占比高的结果更容易得到，也就是效率更高 

但上面的排法并不是WPL最小的

![](C:\Typora\picture\WPL一.png)

![](C:\Typora\picture\WPL二.png)

此时的WPL为205，得到的过程就是从小到大按权重加入结点，看第四幅图，c的权重40，N3的权重为子树的权重之和60，大的摆右边，重复此过程即可得到WPL最小的，但最小不代表最好（这里不再重点表述）

##### 赫夫曼编码：

一般，把需要编码的字符集中的各个字符字符在文中出现的次数或频率看作相应的权重，以此来构建赫夫曼树，**规定树的左支代表0，右支代表1**，解码时则按照01的排序和编码时的赫夫曼树来解码出对应内容

### 2、图⭐☁️

定义：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V,E），其中 G 表示一个图，V 表示图G中的顶点的集合，E是图G中边的集合

顶点：图中数据的元素（图结构中一定有顶点，即V是有穷非空）

图中的逻辑关系：任意两顶点都可能有关系，用边来表示顶点之间的逻辑关系

#### **图的定义及相关概念：**

无向边：顶点v~i~到v~j~之间的边没有方向，用无序偶（v~i~，v~j~）表示

无向图：任意边都是无向边

有向边（弧）：顶点v~i~到v~j~之间的边有方向，用有序偶< v~i~ , v~j~ >,v~i~是弧尾，v~j~是弧头——所以<>里的元素可不能写反

有向图：任意边都是有向边

简单图：同一条边不重复出现，没有自己到自己的边

无向完全图：任意两顶点都存在边——C~n~^2^

有向完全图：任意两顶点都存在方向互反的两条弧——n（n - 1）

稀疏图：很少边或弧（没有一个清除的界限，模糊的概念）

稠密图：与稀疏图相对⛄⛄

权（❄️是的，它又来了❄️）：边或弧相关的数——可以表示一个顶点到另一个顶点的距离或耗费

网：带权的图

**图的顶点与边间的关系：**

无向图中：如果边(v,v~1~)属于图的边集，则称**v和v~1~互为邻接点**，边(v,v~1~)**依附**于顶点v，v~1~，或者说边(v,v~1~)与顶点v，v~1~相关联，与v相关联的边的数目称**度**，各顶点度的一半为边数

有向图中：如果弧< v, v~1~>属于图的边集，称**v邻接到v~1~，v~1~邻接自v**，弧< v, v~1~>与顶点v，v~1~相关联⭐**以顶点v为头的弧的数目称为入度（ID(v)）**⭐，⭐**以v为尾的弧的数目称为出度(OD(v)）**⭐，**顶点的度为TD(v) = ID(v) + OD(v)**，

无向图的路径：顶点序列——可能不是唯一的

有向图的路径：顶点序列（但是要满足弧的方向正确）—— 可能不存在

路径的长度：路径上边或弧的数目

回路（环）：终点，起点为同一个顶点

简单路径：路径序列中，顶点不重复出现

简单回路（简单环）：除了起点终点（因为这是必重复的），其余顶点不重复出现

**连通图的相关术语：**

连通图：无向图中，顶点v到顶点v~1~有路径，称v和v~1~连通，如果图中任意两个顶点连通

连通分量：无向图中的极大连通子图

![](C:\Typora\picture\极大连通子图.png)

![](C:\Typora\picture\极大连通分量二.png)

> 图一是无向非连通图，有两个连通分量图二和图三，图四不是（是子图，但不包含子图的所有顶点）

强连通图：有向图中，每一对v~i~，v~j~都有v~i~到v~j~有路径，v~j~，v~i~有路径（即**我到你，你到我**）

强连通分量：有向图中的极大连通子图![](C:\Typora\picture\强连通分量.png)

> 图一不是强连通图，图二是
>
> 图二是图一的极大强连通子图

连通图的生成树：

![](C:\Typora\picture\连通图的生成树.png)

​        结点：n 边：大于n-1（必有环）           结点：n 边：n-1 (可以是生成树)

![](C:\Typora\picture\连通图的生成树二.png)

​                      结点：n 边：n-1（可以不是生成树）

>  结点：n 边：小于n-1（非连通图）

有向树：只有一个顶点的入度为0，其余都为1

有向图的生成森林：若干有向树组成，含有图中所有顶点，但只有足已构成若干棵不相交的有向树的弧（即图变森林时会去掉一部分弧）

![](C:\Typora\picture\图的生成森林.png)

#### 图的储存结构：

不可能用简单的顺序存储结构实现，多重链表尽管可以实现，但各个顶点的度相差很大，会造成内存浪费

接下来又只能感慨先人的智慧——五种存储结构

##### 1、邻接矩阵

定义：用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（邻接矩阵）储存边或弧的信息

![](C:\Typora\picture\邻接矩阵.png)

邻接矩阵的i行j列取决与（v~i~，v~j~）是否存在——无向图，存在写入1，不存在写入0

> 无向图的邻接矩阵必为对称矩阵，顶点对应行的数字和是度

​                                           < v~i~，v~j~>是否存在——有向图，存在写入1，不存在写入0

> 有向图的邻接矩阵不一定为对称矩阵，顶点对应行的数字和是出度，对应列的数字和是出度

判断两点是否有边，顶点的度，求所有邻接点等所有操作都可以用邻接矩阵实现了，应该不用赘述每一个操作如何实现了吧🥰🥰🥰🥰

接下来讲一下网如何实现——就是多了权而已，下面举例是有向的，无向的类似

![](C:\Typora\picture\邻接矩阵——网.png)

构建时不再是简单的01，而是自己到自己写入0，有边的写权值，没有边的写入计算机公允的∞（一个不可能取到的比所有权值都大的值，是为了更好的表示不存在，因为0和负值都有可能是权值）

代码实现：

```c++
#define INFINITY 65535//无穷大
#define MAXVEX 100//最大顶点数
struct MyGragh
{
	int vexs[MAXVEX];//顶点表
	int arc[MAXVEX][MAXVEX];//邻接矩阵
	int numVertexes, numEdges;//当前顶点数和边数
};
void creatMyGragh(MyGragh& g)
{
	int i, j, k, w;
	cout << "请输入顶点数" << endl;
	cin >> g.numVertexes;
	//创建顶点表
	cout <<"请初始化顶点表" << endl;
	for (i = 0; i < g.numVertexes; i++)
	{
		cin >> g.vexs[i];
	}
	//初始化邻接矩阵
	for (i = 0; i < g.numVertexes; i++)
	{
		for (j = 0; j < g.numVertexes; j++)
		{
			g.arc[i][j] = INFINITY;
		}
	}
	cout << "请输入边数" << endl;
	cin >> g.numEdges;
	for (k = 0; k < g.numEdges; k++)
	{
		cout << "输入需要建立关系的两顶点下标i，j和两顶点之间边的权" << endl;
		cin >> i >> j >> w;
		g.arc[i][j] = w;//赋权值
		g.arc[j][i] = g.arc[i][j];//因为是无向图，当是有向图时不需要这句
	}
} 
```

时间复杂度为O(n^2^)

##### 2、邻接表：

有新的储存方式，往往意味着可以弥补以往的存储形式的某种不足——邻接矩阵是不错的，但当边相对较少时，又会有极大的空间浪费

☝️☝️☝️聪明的你，此时会想到什么？对啊——就是链表（说实话，我没想到），可以节约空间

邻接表——**数组与链表相结合**（之前树的孩子表示用过）

顶点用一维数组存，顶点不仅有数据域，还有指向第一个邻接点的指针

每个顶点的邻接点构成一个线性表（单链表）

> 无向图称上述的单链表为边表，有向图称上述的单链表为顶点作为弧尾的出边表

![](C:\Typora\picture\邻接表.png)

有向图如果想同时直到入度出度，可以引入**逆邻接表**![](C:\Typora\picture\逆邻接表.png)

如果时带权值的网，只需要在边表或者出边表的结点中加入weight的数据域即可

代码实现：

```c++
#define MAXSIZE 100
typedef struct EdgeNode//边表结点
{
	int adjvex;//邻接点域，储存该点的下标
	int weight;//边的权值
	EdgeNode* next;//指向下一个邻接点
}EdgeNode;

typedef struct VexNode//顶点结点
{
	char vexdata;//顶点数据域
	EdgeNode* firstadj;//指向第一个邻接点的指针
}VexNode, AdjList[MAXSIZE];

typedef struct MyGragh//图类型
{
	AdjList adjlist;//定义结点数组
	int numVertexes, numEdges;//顶点和边的数
};
void creatMyGragh(MyGragh& g)
{
	EdgeNode* e = NULL;
	int i, j, k, w;
	cout << "请输入顶点个数" << endl;
	cin >> g.numVertexes;
	cout << "请初始化顶点表" << endl;
	//创建顶点表
	for (i = 0; i < g.numVertexes; i++)
	{
		cin >> g.adjlist[i].vexdata;
		g.adjlist[i].firstadj = NULL;//初始化指向空
	}
	cout << "请输入边数" << endl;
	cin >> g.numEdges;
	for (k = 0; k < g.numEdges; k++)
	{
			cout << "输入需要建立关系的两顶点下标i，j和两顶点之间边的权" << endl;
			cin >> i >> j >> w;
			e = new EdgeNode;
			e->weight = w;//赋权值
			e->adjvex = j;//邻接点
			e->next = g.adjlist[i].firstadj;//头插法
			g.adjlist[i].firstadj = e;
			e = new EdgeNode;//有向则不需要后面这部分
			e->weight = w;//赋权值
			e->adjvex = i;//邻接点
			e->next = g.adjlist[j].firstadj;
			g.adjlist[j].firstadj = e;
	}
}
```

##### 3、十字链表（有向图使用）

把邻接表和逆邻接表结合

![](C:\Typora\picture\十字链表.png)

边表结点就相当于把边存进去了，tailvex对应弧尾，headtex对应弧头，taillink指向下一个以同一顶点为弧尾的边表结点（比如：结点1的边表结点中，==1==到0结点的taillink指向==1==到2结点），headlink指向下一个以同一个顶点为弧头的边表结点（比如：1到==0==的结点的headlink指向2到==0==的结点）

代码实现：

```c++
#define MAXSIZE 100
typedef struct EdgeNode//边表结点
{
	int tailvex;//储存弧起点在顶点表下标
	int headvex;//储存弧终点在顶点表下标
	int weight;//权值
	EdgeNode* headlink = NULL;//入边表指针域
	EdgeNode* taillink = NULL;//边表指针域——对应结点作为弧尾
}EdgeNode;

typedef struct VexNode//顶点结点
{
	char vexdata;//顶点数据域
	EdgeNode* firstin;//第一个入边表指针
	EdgeNode* firstout;//第一个出边表指针
}VexNode, AdjList[MAXSIZE];
typedef struct MyGragh//图类型
{
	AdjList adjlist;//定义结点数组
	int numVertexes, numEdges;//顶点和边的数
};
void creatMyGragh(MyGragh& g)
{
	EdgeNode* e = NULL;
	int i, j, k, w;
	cout << "请输入顶点个数" << endl;
	cin >> g.numVertexes;
	cout << "请初始化顶点表" << endl;
	//创建顶点表
	for (i = 0; i < g.numVertexes; i++)
	{
		cin >> g.adjlist[i].vexdata;
		g.adjlist[i].firstin = NULL;//初始化指向空
		g.adjlist[i].firstout = NULL;
	}
	cout << "请输入边数" << endl;
	cin >> g.numEdges;
	for (k = 0; k < g.numEdges; k++)
	{
		cout << "输入需要建立关系的两顶点下标i，j和两顶点之间边的权" << endl;
		cin >> i >> j >> w;
		e = new EdgeNode;
		e->tailvex = i;//弧尾赋值
		e->headvex = j;//弧头赋值
		e->weight = w;//赋权值
		e->taillink = g.adjlist[i].firstout;//头插法插入顶点i的出边表
		g.adjlist[i].firstout = e;
		e->headlink = g.adjlist[j].firstin;//头插法插入顶点j的入边表
		g.adjlist[j].firstin = e;
	}
}
```

##### 4、邻接多重表（无向图使用）

关注的重点是顶点时，用邻接表挺好的，但如果我们更加关注边（访问过做标记，删除等），此时邻接表则比较麻烦——接下来我们仿照十字链表对邻接表进行改造。

**邻接多重表**：ivex与jvex是某条边的依附的两个顶点在顶点表中下标（与十字链表一样，把==边的信息更完整的存储下来==，便于操作），ilink指向依附顶点ivex的下一条边，jlink指向依附于顶点jvex的下一条边

![](C:\Typora\picture\多重邻接表.png)

```c++
#define MAXSIZE 100
typedef struct EdgeNode//边表结点
{
	int ivex, jvex;//储存顶点i,j的下标
	int weight;//边的权值
	EdgeNode* ilink;//指向下一个含i的边表结点
	EdgeNode* jlink;//指向下一个含j的边表结点
}EdgeNode;

typedef struct VexNode//顶点结点
{
	char vexdata;//顶点数据域
	EdgeNode* firstadge;//指向第一个邻接点的指针
}VexNode, AdjList[MAXSIZE];

typedef struct MyGragh//图类型
{
	AdjList adjlist;//定义结点数组
	int numVertexes, numEdges;//顶点和边的数
};
void creatMyGragh(MyGragh& g)
{
	EdgeNode* e = NULL;
	int i, j, k, w;
	cout << "请输入顶点个数" << endl;
	cin >> g.numVertexes;
	cout << "请初始化顶点表" << endl;
	//创建顶点表
	for (i = 0; i < g.numVertexes; i++)
	{
		cin >> g.adjlist[i].vexdata;
		g.adjlist[i].firstadge = NULL;//初始化指向空
	}
	cout << "请输入边数" << endl;
	cin >> g.numEdges;
	for (k = 0; k < g.numEdges; k++)
	{
		cout << "输入需要建立关系的两顶点下标i，j和两顶点之间边的权" << endl;
		cin >> i >> j >> w;
		e = new EdgeNode;
		e->ivex = i;//边表结点赋值
		e->jvex = j;
		e->weight = w;
		e->ilink = g.adjlist[i].firstadge;//对顶点i头插法
		g.adjlist[i].firstadge = e;
		e->jlink = g.adjlist[j].firstadge;//对顶点j头插法
		g.adjlist[j].firstadge = e;
	}
}
```

##### 5、边集数组

定义：由两个一维数组构成，一个存顶点，一个存边的信息，这个边数组每个数据元素由一条边的起点下标、终点下标和权组成（显然当要查一个顶点的度时，效率不高），但适合对边依次进行处理（后面的克鲁斯卡尔算法介绍应用）

![](C:\Typora\picture\边集数组.png)

代码实现：略——简单

#### 图的遍历：

定义：从图中某一个顶点出发访问图中其余顶点，且每一个顶点仅被访问一次

两种遍历次序方案：

##### 深度优先搜索（Depth_First_Search）——DFS

![](C:\Typora\picture\DFS.png)

其实就是一个递归的过程，转换成右图中可以看出其实就是树的前序遍历

从图中某顶点v出发，访问这个顶点，然后从v未被访问的邻接点出发DFS，直至所有顶点被访问到

> 上图是连通图的过程，非连通图一样的，每个连通分量找一个顶点进行访问即可

主要是要设置**访问标志数组**

代码实现：

```c++
//邻接矩阵的深度优先搜素
int visited[MAXVEX];
void DFS(MyGragh& g, int i)
{
	int j;
	visited[i] = true;
	cout << g.vexs[i] << endl;//打印此结点，可以换成其他操作
	for (j = 0; j < g.numVertexes; j++)
	{
		if (g.arc[i][j] != INFINITY && visited[j] == false)
		{
			DFS(g, j);
		}
	}
}
void DFSTravers(MyGragh& g)
{
	int i;
	for (i = 0; i < g.numVertexes; i++)//初始化标志数组
	{
		visited[i] = false;
	}
	for (i = 0; i < g.numVertexes; i++)//如果是连通图只会进入一次
	{
		if (visited[i] == false)
		{
			DFS(g, i);
		}
	}
}


//邻接表的深度优先搜素
int visited[MAXSIZE];
void DFS(MyGragh& g, int i)
{
	EdgeNode *p;
	visited[i] = true;
	cout << g.adjlist[i].vexdata << endl;//打印此结点，可以换成其他操作
	for (p = g.adjlist[i].firstadj; p; p = p->next)
	{
		if (!visited[p->adjvex])
		{
			DFS(g, p->adjvex);
		}
	}
}
void DFSTravers(MyGragh& g)
{
	int i;
	for (i = 0; i < g.numVertexes; i++)//初始化标志数组
	{
		visited[i] = false;
	}
	for (i = 0; i < g.numVertexes; i++)//如果是连通图只会进入一次
	{
		if (!visited[i])
		{
			DFS(g, i);
		}
	}
}
```

##### 广度优先搜索（Breadth_First_Search）——BFS

![](C:\Typora\picture\BFS.png)

这就类似于树的层序遍历

代码实现：

```c++
//邻接表的广度优先搜素
int visited[MAXSIZE];
void BFSTravers(MyGragh& g)
{
	int i;
	EdgeNode* p;
	queue<int> q;
	for (i = 0; i < g.numVertexes; i++)//初始化标志数组
	{
		visited[i] = false;
	}
	for (i = 0; i < g.numVertexes; i++)//循环,是为了解决非连通图的情况
	{
		if (!visited[i])
		{
			visited[i] = true;
			cout << g.adjlist[i].vexdata << endl;;//打印顶点也可以是其他操作
			q.push(i);
			for (p = g.adjlist[i].firstadj; p; p = p->next)
			{
				i = q.front();//队首元素赋值给i
				q.pop();
				p = g.adjlist[i].firstedge;//找到当前顶点边表链表头指针
				if (!visited[p->adjvex])//若此结点未访问
				{
					visited[p->adjvex] = true;
					cout << g.adjlist[p->adjvex].vexdata << endl;
					q.push(p->adjvex);//此顶点入队
				}
			}

		}
	}
}

//邻接矩阵的广度优先搜素
int visited[MAXVEX];
void BFSTravers(MyGragh& g)
{
	int i, j;
	queue<int> q;
	for (i = 0; i < g.numVertexes; i++)//初始化标志数组
	{
		visited[i] = false;
	}
	for (i = 0; i < g.numVertexes; i++)//循环,是为了解决非连通图的情况
	{
		if (!visited[i])
		{
			cout << g.vexs[i] << endl;
			visited[i] = true;
			q.push(i);
			while (!q.empty())
			{
				i = q.front();
				q.pop();
				for (j = 0; j < g.numVertexes; j++)
				{
					if (!visited[j] && g.arc[i][j] != INFINITY)
					{
						visited[j] = true;
						cout << g.vexs[j] << endl;
						q.push(j);
					}
				}
			}
		}

	}
}
```

#### 最小生成树：

定义：构造连通网的最小代价生成树（连通图的生成树定义看之前的讲解）

找连通图的最小生成树的两种经典算法：

优秀视频资源：[(最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Eb41177d1?spm_id_from=333.337.search-card.all.click))

##### 普里姆算法（Prim）

![](C:\Typora\picture\prim最小生成树.png)

构造两个数组，lowcost[i]表示当前所包含的结点到i的最小权值，每多一个结点入生成树更新一次lowcost数组，adjvex数组也需要同时更新，因为adjvex[i]存的**当时**到i的最小权值对应的结点

```c++
//Prim算法求最小生成树
void miniSpanTree_prim(MyGragh& g)
{
	int min, i, j, k;
	int lowcost[MAXVEX];
	int adjvex[MAXVEX];
	//两个数组首元素初始化，这里从v0开始，实际上从哪一个开始都一样
	adjvex[0] = 0;
	lowcost[0] = 0;//lowcost为0表示该顶点已经入
	for (i = 1; i < g.numVertexes; i++)
	{
		lowcost[i] = g.arc[0][i];//先把v0相关的边的权值录入
		adjvex[i] = 0;
	}
	for (i = 1; i < g.numVertexes; i++)//adjvex还需要找到顶点个数减1个元素
	{
		min = INFINITY;//min的初始化
		k = 0;
		for (j = 1; j < g.numVertexes; j++)//循环找到lowcost此时的最小权值
		{
			if (lowcost[j] != 0 && lowcost[j] < min)//该顶点还没进adjvex并且权值在lowcost中更小
			{
				min = lowcost[j];
				k = j;//用k来存最小权值
			}
		}
		cout << "(" << adjvex[k] << "," << k << ")" << endl;//打印当前权值最小边,adjvex中记录的是到该顶点最近的点
		lowcost[k] = 0;//当前顶点的权值设置为0，表示该结点已经入树
		for (j = 1; j < g.numVertexes; j++)//循环所有点
		{
			if (lowcost[j] != 0 && g.arc[k][j] < lowcost[j])//顶点未入树且到此顶点的最小权值更新
			{
				lowcost[j] = g.arc[k][j];//最小权值存入
				adjvex[j] = k;//对应下标存入
			}
		}
	}
}
```

##### 克鲁斯卡尔算法（kruskal）：

重要思想：边的权值先排好序，按从小到大依次放入生成树中，所以最重要的步骤是判断是否能放入（**是否能形成环**）——这里使用parent数组判断（**内化为自己的方法**）

![](C:\Typora\picture\kruskal判断是否成环手稿.jpg)

```c++
struct Edge
{
	int begin;
	int end;
	int weight;
};

//Kruskal算法求最小生成树
int find(int* parent,int f)
{
	while (parent[f] > 0)
	{
		f = parent[f];
	}
	return f;
}
void miniSpanTree_kruskal(MyGragh& g)
{
	int i, j, k = 0, m, n;
	Edge edges[MAXEDGE];
	int parent[MAXVEX];
	for (j = 0; j < g.numVertexes; j++)//按矩阵的上三角化为边集合
	{
		for (i = 0; i < j + 1; i++)
		{
			if (g.arc[i][j] != INFINITY)
			{
				edges[k].begin = i;
				edges[k].end = j;
				edges[k].weight = g.arc[i][j];
				k++;
			}
		}
	}
	for (i = 1; i < k ; i++)//边按权值排序，这里用冒泡排序实现，以后学到八大排序再更改
	{
		for (j = 0; j < k - i; j++)
		{
			if (edges[j].weight > edges[j + 1].weight)
			{
				Edge temp = edges[j];
				edges[j] = edges[j + 1];
				edges[j + 1] = temp;
			}
		}
	}
	for (i = 0; i < g.numVertexes; i++)
	{
		parent[i] = 0;//这个是结点是否成环的判断方式,必须学会
	}
	for (i = 0; i < g.numEdges; i++)//循环每一条边
	{
		n = find(parent, edges[i].begin);
		m = find(parent, edges[i].end);
		if (n != m)//如果是在同一相等的顶点集合中，n和m必定相等
		{
			parent[n] = m;//将此边的结尾放入起点下标为起点的parent中，表示已经在生成树集合中
			cout << "(" << edges[i].begin << "," << edges[i].end << ")" << " 权值为: " << edges[i].weight << endl;
		}
	}
}
```

#### 最短路径：

定义：非网图（边上无权值）——所以两顶点间边数最少就是最短路径

​	     网图（边上有权值）——两顶点间经过的边上权值和的最少路径，称**第一个顶点为源点，最后一个顶点是终点**

优质网络资源:[Dijkstra(迪杰斯特拉)算法理解_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1QK411V7V4?spm_id_from=333.337.search-card.all.click)

##### 迪杰斯特拉（Dijkstra）算法：

精髓：创建一个标志数组标志对应的顶点最短距离是否已经找到，其实这个算法用到了贪心算法的要点——每进行一步进行一次更新，以便找到最好方法，也就是我们既然不能一蹴而就找到0到n的最短，我们就先找靠0近的顶点，找一个更新一次到剩余顶点的最小值😘😘想出来的简直是人才😘😘

代码实现：

```c++
typedef int pathmatirx[MAXVEX];//存最短路径中对应顶点的前驱
typedef int shortPathTable[MAXVEX];//此时到这个点的最小权值和
void shortestPath_Dijkstra(MyGragh g, int v0, pathmatirx& P, shortPathTable& D)
{
	int i, j, k = 0, min;
	bool final[MAXVEX];//定义标志数组，表示v0到对应顶点的最短路径是否已经求出
	for (i = 0; i < g.numVertexes; i++)//各数组初始化
	{
		final[i] = 0;//0表示还没算出
		P[i] = 0;
		D[i] = g.arc[v0][i];//初始化为传入顶点的相邻边的权值
	}
	D[v0] = 0;//v0到v0权值为0
	final[v0] = 1;//v0已经找到
	for (i = 1; i < g.numVertexes; i++)//找到v0到其余顶点的最小权值
	{
		min = INFINITY;
		for (j = 0; j < g.numVertexes; j++)//循环此时到所有顶点的最小权值
		{
			if (!final[j] && D[j] < min)//找到记录权值数组中的最小权值
			{
				min = D[j];
				k = j;//记录下此时的最小点
			}
		}

		final[k] = 1;//找到最小标记完成
		for (j = 0; j < g.numVertexes; j++)//路径已经多了一个点，当然要更新一下此时的到各个顶点的最小权值，有点像prim，体现贪心算法
		{
			if (!final[j] && min + g.arc[k][j] < D[j])
			{
				D[j] = min + g.arc[k][j];//更新最小权值 
				P[j] = k;//记录最小路径对应的前驱，以便表达
			}
		}
	}
}
```

时间复杂度O(n^2^)，解决了从某个源点到其余各个顶点的最短路径的问题，但有些人还是觉得，我想知道各个点之间的最短路径——接下来请欣赏算法的艺术——弗洛伊德

##### 弗洛伊德（Floyd）算法：

优质资源：[图论最短距离(Shortest Path)算法动画演示-Dijkstra(迪杰斯特拉)和Floyd(弗洛伊德)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1q4411M7r9?spm_id_from=333.337.search-card.all.click)

首先初始化数组，原本从i到j后驱是j，所以P数组中i的后缀存j

![](C:\Typora\picture\弗洛伊德算法.png)

算法精髓![](C:\Typora\picture\弗洛伊德算法精髓.png)

原理其实很简单，两点之间一定有一个最短距离（这是一定的），如果我们找得到一个中间点使得到终点的距离更短，那就说明这一点更有可能在最短路径上，直接更新P数组的i行j列变成k，k相当于一个跳板，继续将k看成起点往后找，一定可以找到，**因为这个算法把任意两个点之间的跳板都试过了**，最后的D数组一定是所有的最短路径了 

⚡⚡完全就是艺术啊⚡⚡——俗称forforfor算法

代码实现：

```c++
typedef int pathmatirx[MAXVEX][MAXVEX];//存最短路径中对应顶点的前驱
typedef int shortPathTable[MAXVEX][MAXVEX];//此时到这个点的最小权值和
void shortestPath_Floyd(MyGragh g, pathmatirx& P, shortPathTable& D)
{
	int i, j, k;
	for (i = 0; i < g.numVertexes; i++)
	{
		for (j = 0; j < g.numVertexes; j++)
		{
			D[i][j] = g.arc[i][j];//初始化最短权值数组为邻接矩阵
			P[i][j] = j;//初始化路径数组为终点
			//if (i == j)
			//{
			//	D[i][j] = 0;//自己到自己为0
			//}
		}
	}
	for (k = 0; k < g.numVertexes; k++)
	{
		for (i = 0; i < g.numVertexes; i++)
		{
			for (j = 0; j < g.numVertexes; j++)
			{
				if (D[i][k] + D[k][j] < D[i][j])//如果先到中间的某一个结点比原先记录的更短，更新
				{
					D[i][j] = D[i][k] + D[k][j];
					P[i][j] = P[i][k];
				}
			}
		}
	}
}
```

解决**所有顶点到所有顶点**的最短路径问题，时间复杂度为O(n^3^)

注意：这==两个方法对有向图无向图都适用==，这两种图其实也就是矩阵对不对称而已，我们在==设计算法的时候并没有用到矩阵是否对称==——那么就是普适的，所以不要纠结，大胆去用这两个神一样的方法吧

#### 拓扑排序：

介绍：我们会把一个项目分为许多子工程，这些活动会有先后之分（也就是要完成哪一步才能进行下一步）

下图为示例![](C:\Typora\picture\拓扑排序介绍.png)

**AOV网**（activity on vertex network）定义：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网

拓扑序列：n个结点的有向图中，若从v~i~到v~j~有一条路径，则顶点v~i~ **必在**顶点v~j~之前

（v省略没写），上图中拓扑序列有两条

（0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16）

（0 1 4 3 2 7 6 5 8 10 9 12 11 14 13 15 16）

拓扑排序：构造拓扑序列的过程

##### 拓扑排序算法：

基本思路：从AOV网中选择入度为0的顶点输出，然后删去这个顶点和以这个顶点为尾的弧

==借助了另一种数据结构栈==，顶点结构中还需要**加入入度域**

AOV图中一定不存在环，假**但凡输出的顶点少了一个**就说明有回路，就不再是AOV环了

![](C:\Typora\picture\拓扑排序.png)

结构实现：

```c++
typedef struct EdgeNode//边表结点
{
	int adjvex;//邻接点域，储存该点的下标
	int weight;//边的权值
	EdgeNode* next;//指向下一个邻接点
}EdgeNode;

typedef struct VexNode//顶点结点
{
	int vexdata;//顶点数据域
	int in;//记录此顶点的入度
	EdgeNode* firstadj;//指向第一个邻接点的指针
}VexNode, AdjList[MAXSIZE];

typedef struct MyGragh//图类型
{
	AdjList adjlist;//定义结点数组
	int numVertexes, numEdges;//顶点和边的数
};
```

代码实现：

```c++
int toPoLogicalSort(MyGragh& g)
{
	EdgeNode* e;//遍历指针
	int i = 0,k = 0;
	int top = 0;//栈顶指针 
	int gettop = 0;//储存出栈元素
	int* stack;//stack用来管理栈
	int count = 0;//用来记录输出的顶点个数

	stack = new int[MAXSIZE];
	for (i = 0; i < g.numVertexes; i++)//循环每一个顶点找到入度为0的入栈
	{
		if (!g.adjlist[i].in)
		{
			stack[++top] = i;
		}
	}
	while (top != 0)
	{
		gettop = stack[top--];//出栈
		cout << " " << g.adjlist[gettop].vexdata << " ";//输出顶点
		count++;
		for (e = g.adjlist[gettop].firstadj; e; e = e->next)
		{
			k = e->adjvex;//k记录此时顶点下标
			if (!(--g.adjlist[k].in))
			{
				stack[++top] = k;
			}
		}
	}
	if (count < g.numVertexes)
	{
		return 0;//表示没有形成AOV图
	}
	else
	{
		return 1;//表示成功形成AOV图
	}
}

```

#### 关键路径：

拓扑排序解决工程能否顺利进行，我们还要解决工程完成的最短时间问题

**AOE网**（activity on edge network）：在表示工程的带权有向图中，用顶点表示事件，有向边表示活动，用边上的权值表示活动持续时间，有向图的边表示活动的网

![](C:\Typora\picture\AOV对比AOE.png)

路径长度：路径上各个活动所持续的时间之和

**关键路径**：从源点到汇点具有==最大长度==的路径

原理：找到所有活动中最早开始时间和最晚开始时间，比较它们，相等就是关键活动

![](C:\Typora\picture\关键路径定义量.png)

关于每个变量的通俗理解：

> etv：a到c要3min，b到c要5min，你想要做c，不等5min你能做？（c开始的前提是a，b都做完）
>
> ltv：由etv已经找到最后一个事件的最早开始时间，其实就是整个工程完成所需时间，c最早时间是8min，b到c要5min，b的最晚发生时间是3min，你3min时还不开始做b你做得完？

etv数组和ltv数组都是为了求活动的最早和最晚，==两者相等就一定是在关键路径上==

口诀：==早尾晚头==

> ete：最早时间是弧尾顶点事件对应的最早时间
>
> ete = etv[i]

> lte = 最晚时间是弧头顶点事件对应的最晚时间 - 弧的权值
>
> let = ltv[k] - e->weight

算法：

结构不同之处在于——边上加权值域

```c++
int* etv, * ltv;//维护事件最早时间和最晚时间数组
int* stack2;//将从stack1中出栈的元素压进stack2
int top2;//栈2的指针
int toPoLogicalSort(MyGragh& g)
{
	EdgeNode* e;//遍历指针
	int i = 0,k = 0;
	int top = 0;//栈顶指针 
	int gettop = 0;//储存出栈元素
	int* stack1;//stack1用来管理栈
	int count = 0;//用来记录输出的顶点个数
	stack1 = new int[MAXSIZE];
	for (i = 0; i < g.numVertexes; i++)//循环每一个顶点找到入度为0的入栈
	{
		if (!g.adjlist[i].in)
		{
			stack1[++top] = i;
		}
	}
	top2 = 0;//初始化为0
	etv = new int[MAXSIZE];
	stack2 = new int[MAXSIZE];
	for (i = 0; i < g.numVertexes; i++)
	{
		etv[i] = 0;//初始化
	}
	while (top != 0)
	{
		gettop = stack1[top--];//出栈
		count++;
		stack2[++top2] = gettop;//弹出的数据压进stack2
		for (e = g.adjlist[gettop].firstadj; e; e = e->next)
		{
			k = e->adjvex;//k记录此时顶点下标
			if (!(--g.adjlist[k].in))
			{
				stack1[++top] = k;
			}
			if (etv[gettop] + e->weight > etv[k])//事件最早时间存最大值
			{
				etv[k] = etv[gettop] + e->weight;
			}
		}
	}
	if (count < g.numVertexes)
	{
		return 0;//表示没有形成AOV图
	}
	else
	{
		return 1;//表示成功形成AOV图
	}
}
void criticalPath(MyGragh& g)
{
	EdgeNode* e;
	int i = 0,k = 0;
	int ete = 0, lte = 0;//活动的最早时间和最晚时间
	int gettop;
	ltv = new int[MAXSIZE];
	toPoLogicalSort(g);
	for (i = 0; i < g.numVertexes; i++)
	{
		ltv[i] = etv[g.numVertexes - 1];//求最晚时间是以最后一个事件的最早时间开始
	}
	while (top2 != 0)
	{
		gettop = stack2[top2--];
		for (e = g.adjlist[gettop].firstadj; e; e = e->next)
		{
			k = e->adjvex;
			if (ltv[k] - e->weight < ltv[gettop])
			{
				ltv[gettop] = ltv[k] - e->weight;
			}
		}
	}
	for (i = 0; i < g.numVertexes; i++)
	{
		for (e = g.adjlist[i].firstadj; e; e = e->next)
		{
			k = e->adjvex;
			ete = etv[i];//早尾
			lte = ltv[k] - e->weight;//晚头
			if (ete == lte)
			{
				cout << i << "->" << k << endl;
			}
		}
	}
}
```

