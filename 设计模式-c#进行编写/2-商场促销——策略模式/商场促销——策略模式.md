# 商场促销——策略模式

## 不打折收费系统
****
能实现简单的不做任何额外打折的收银系统

![商品促销模式1](picture/第二章/商品促销模式1.png)

## 加入简单的打折功能

![商品促销模式2](picture/第二章/商品促销模式2.png)

## 简单工厂功能实现

此处上一节已经讲解的非常详细了，创造一个收费方式制造工厂，每次加一个收费方式的时候加一个类继承总收费方式类，再在制造工厂加一个分支

==但此处还是引出了一些不必要的麻烦，商场大部分时候只是想改变一下打折额度和返利额度，经常对代码进行更改和编译也是十分不妥的方式，所以我们需要更合理的实现——策略模式==

## 🙄🙄策略模式(Strategy )

`在策略模式c#工程里保存的是策略模式的演示项目`

![商品促销模式3](picture/第二章/商品促销模式3.png)

### 策略模式解析

**抽象类部分**

![策略模式解析一](picture/第二章/策略模式解析一.png)

**具体实现类部分**

![策略模式解析二](picture/第二章/策略模式解析二.png)

**用于维护抽象策略类部分(==策略的选择部分可以在构造函数中完成==)**

![策略模式解析三](picture/第二章/策略模式解析三.png)

**客户端部分==此处就可以看出和工厂模式有些类似，只是客户端更加简洁了==**

![策略模式解析四](picture/第二章/策略模式解析四.png)

**分析：**

策略模式是一种定义一系列算法的方法，从概念上来看，所有算法完成的是==同一种工作，只是实现不同==

Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于==析取出算法中的公共功能==

优点：简化了==单元测试==，每个算法有自己的类，可以通过自己的接口单独测试

注意点：基本的策略模式中，==选择所用的具体实现的职责由客户端对象承担==，并==转给策略模式的Context对象【DPE】==

但是，这也不是我们最经常用的方法，我们在Context里还是用到了Switch，加一个策略的时候还是要来这里改，还是十分的**不爽**，之后会提到**==反射技术==**会解决这个问题