# 简历复印—原型模式

> 定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

![原型模式结构图](C:\Typora\设计模式picture\第九章\原型模式结构图.png)

==原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节==

![原型模式1](C:\Typora\设计模式picture\第九章\原型模式1.png)

`MemberwiseClone：创建当前对象的浅表副本。创建一个新对象，然后复制对象的非静态对象，值类型则逐位复制，引用类型则复制引用而不复制引用的对象，即引用对象一致`

==注意：对于.NET而言，原型抽象类Prototype是用不着的，Clone太常用了，.NET在System命名空间中提供了ICloneable接口，实现接口就完成了原型模式==![原型模式第一版结果](C:\Typora\设计模式picture\第九章\原型模式第一版结果.png)

上图是第一版原型模式的结果，==一个重要的亮点，String难道不是引用类型吗，为什么更改之后还是显示了不同的结果？这不是值类型的特点吗？==

> 原因：String的不变性
>
> String对象称为不可变的，因为**一旦创建**了该对象，**就不能修改该对象**的值。有的时候**看来似乎修改**了，实际是**string经过了特殊处理**，每次**改变值时**都会**建立一个新的string对象**，**变量**会**指向这个新的对象**，而**原来**的还是**指向原来**的对象，所以不会改变。这也是**string效率低下的原因**。如果**经常改变**string的值则应该**使用StringBuilder而不使用string**。

Clone：一般在初始化信息不发生变化的情况下，克隆是最好的办法，既隐藏了对象创建的细节，又对性能是大大的提高，==不新初始化对象，而是动态获得对象运行时的状态==

## 浅复制与深复制(补充知识)

![原型模式第二版结果](C:\Typora\设计模式picture\第九章\原型模式第二版结果.png)

假如Clone引用类型，就会导致以上结果，这就是"==浅复制=="，所有的对其他对象的引用都仍然指向原来的对象，==“深复制”一般的需求是要复制的对象所引用的对象都复制一遍==

